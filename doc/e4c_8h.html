<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>exceptions4c: e4c.h File Reference</title>
	<link href="exceptions4c.css" rel="stylesheet" type="text/css" />
	<link href="tabs.css" rel="stylesheet" type="text/css" />
	<link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB+ElEQVQ4jaVTO4sTURT+5sFOnuxMYsyYTMAwMTAkgUk200waK0EYsLCb1sbeYksHW8FfYKGFUUFYsNFGCIpYBGOTNWJhbCwiCYMQyMZ17rFYbswm4AM/OHDveXz3nI9zBSLC/0Dmh06no85ms+uJROLzYDB49NcMRIRms3lZVdVDURR/ZLPZN9Vq9WqtVtshIvzJBMdxWsPh8OlisShwUkmSjvP5/H1VVd/GYrFP8/l8T5Kk/HK5/A4gisfjYwDy7u7uQ+i6/gwA+515nkdBENCGnxzH2YdlWXa9Xr+kKMo3AMz3fSIi8n2feHGv1yM6UftUXNO0F6tZMpnMawCMJxIR8eITqU77iYgMw/i6Isjlcgc8gSMIgvUrdbtdTkQAKJ1Of1wRmKZ5m7/ked7mvFudbXXQarUuiqJ4zGfkBZsEmxoIfBMtyxIB3JhMJtfCMKwCgCiKR4IgHAGIMcZiRETJZPILACGKop1Go3FnRcDhum55NBo9YYwlDcPYl2X5XSqVssMwbE6n006hUHgsSdLL8Xj83LKsva3Nsm27VKlUbpqmeXczVi6Xb7Xb7RoRoVQqHRDRr7/AoSjKhSiKPhCRse63bTvFGFP7/f6h67rnZFl+D2CbAMAZXddfhWF4dt2padr5RCLxAAAEQbhSLBbvAcCWBv+Kn6GeeP3SvcIWAAAAAElFTkSuQmCC" rel="shortcut icon" />
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<h1>e4c.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>exceptions4c header file  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;setjmp.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structe4c__exception.html">e4c_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an exception in the exception handling system.  <a href="structe4c__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a map between a signal and an exception.  <a href="structe4c__signal__mapping.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exception handling keywords</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This set of keywords express the semantics of exception handling.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee">try</a>&#160;&#160;&#160;E4C_TRY</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code aware of exceptions.  <a href="#a28599e8ac99ea9faff60a2258a914aee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026">catch</a>(_exception_type_)&#160;&#160;&#160;E4C_CATCH(_exception_type_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code capable of handling a specific kind of exceptions.  <a href="#a298c59325609e266f86aad4f31899026"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454">finally</a>&#160;&#160;&#160;E4C_FINALLY</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code responsible for cleaning up the previous <code>try</code> block.  <a href="#a6f547472794c162cc629f53cd4db5454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4">retry</a>(_max_retry_attempts_)&#160;&#160;&#160;E4C_RETRY(_max_retry_attempts_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the previous E4C_TRY (or E4C_USE) block entirely.  <a href="#a97c358e50b2f416cd3ce25ed983cbeb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e">throw</a>(_exception_type_, _message_)&#160;&#160;&#160;E4C_THROW(_exception_type_, _message_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals an exceptional situation represented by an exception object.  <a href="#a09a8a3f0ee6335f6d59ae7da4919b46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a08cf0d726d15a42dbc3dbfe41bb45353">rethrow</a>(_message_)&#160;&#160;&#160;E4C_RETHROW(_message_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws again the currently thrown exception, with a new message.  <a href="#a08cf0d726d15a42dbc3dbfe41bb45353"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dispose pattern keywords</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This set of keywords express the semantics of automatic resource acquisition and disposal.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339">with</a>(_resource_, _dispose_)&#160;&#160;&#160;E4C_WITH(_resource_, _dispose_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a block of code with automatic disposal of a resource.  <a href="#a94ef1cc39e565b84c25ca340af8d3339"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aeda5446032a08fece73ec569b861a72c">use</a>&#160;&#160;&#160;E4C_USE</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a block of code with automatic disposal of a resource.  <a href="#aeda5446032a08fece73ec569b861a72c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a4099c93334aae15414f9f91f11fecb8d">using</a>(_type_, _resource_, _args_)&#160;&#160;&#160;E4C_USING(_type_, _resource_, _args_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code with automatic acquisition and disposal of a resource.  <a href="#a4099c93334aae15414f9f91f11fecb8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ab667a8f4f3b49bbfc2190bb01faf64fd">reacquire</a>(_max_acquire_attempts_)&#160;&#160;&#160;E4C_REACQUIRE(_max_acquire_attempts_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the previous E4C_WITH block entirely.  <a href="#ab667a8f4f3b49bbfc2190bb01faf64fd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convenience macros for acquiring and disposing resources</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros let you acquire and dispose different kinds of resources according to the <em>dispose pattern</em>.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa">e4c_using_memory</a>(_buffer_, _bytes_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code with automatic acquisition and disposal of a memory buffer.  <a href="#a9f9d90ec6662db343293a3cabad26caa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f">e4c_using_file</a>(_file_, _path_, _mode_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code with automatic acquisition and disposal of a file stream.  <a href="#aadb996e59894bfeec035af1b8ca0547f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ac267831edf6e221dd463f56f02fa4561">e4c_using_if</a>(_type_, _resource_, _args_, _cond_, _exception_, _msg_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code with automatic disposal of a resource and acquisition, under certain condition.  <a href="#ac267831edf6e221dd463f56f02fa4561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a17b01b3e04b99590d572db88feca7479">e4c_using_if_not_null</a>(_type_, _resource_, _args_, _exception_, _msg_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code with automatic disposal of a resource and acquisition, preventing null pointers.  <a href="#a17b01b3e04b99590d572db88feca7479"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Integration macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros are designed to ease the integration of external libraries which make use of the exception handling system.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8">E4C_VERSION_NUMBER</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library version number.  <a href="#aaabdc92526a7fb8e02558867f3ad0cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a28f15bc301e1a0a004040d0f2c196139">E4C_VERSION_THREADSAFE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library thread mode (either single-thread or multi-thread)  <a href="#a28f15bc301e1a0a004040d0f2c196139"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a890f79613092dcd580078ff46babfb6e">E4C_VERSION_MAJOR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library major version number.  <a href="#a890f79613092dcd580078ff46babfb6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aa4564247c8f8fa73e293f24e9790e2b5">E4C_VERSION_MINOR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library minor version number.  <a href="#aa4564247c8f8fa73e293f24e9790e2b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a472fdc2124dfc3fc50680cbf5811c868">E4C_VERSION_REVISION</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library revision number.  <a href="#a472fdc2124dfc3fc50680cbf5811c868"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aea131104dcb566c9e4d134c476758b2c">E4C_VERSION_STRING</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the library version number as a string literal.  <a href="#aea131104dcb566c9e4d134c476758b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a221e306037ef73b1788ddd261088230f">E4C_EXCEPTION_MESSAGE_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the maximum length (in bytes) of an exception message.  <a href="#a221e306037ef73b1788ddd261088230f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001">e4c_reusing_context</a>(_thrown_exception_)&#160;&#160;&#160;_E4C_REUSING_CONTEXT(_thrown_exception_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuses an existing exception context, otherwise, begins a new one and then ends it.  <a href="#ac1746d33d024fbe62d6edf60113d2001"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Other convenience macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros provide a handy way to: begin (and end) implicitly a new exception context, express <em>assertions</em>, define and declare exceptions, and define arrays of signal mappings.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37">e4c_using_context</a>(_handle_signals_, _uncaught_handler_)&#160;&#160;&#160;_E4C_USING_CONTEXT(_handle_signals_, _uncaught_handler_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a block of code which will use a new exception context.  <a href="#a7851c828f2a8203c99eb81fe8f9a2e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a375b90620a57f874e38fdf35ed713b6a">e4c_assert</a>(_condition_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses a program assertion.  <a href="#a375b90620a57f874e38fdf35ed713b6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a9b1624a792d8464fe0958f8713b25d0c">throwf</a>(_exception_type_, _format_,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception with a formatted message.  <a href="#a9b1624a792d8464fe0958f8713b25d0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a91a9c5527cbdc3a41573c126c78a7bd9">rethrowf</a>(_format_,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws again the currently thrown exception, with a new, formatted message.  <a href="#a91a9c5527cbdc3a41573c126c78a7bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a3a605647d641eb5c21f5ae634bfcda50">E4C_DECLARE_EXCEPTION</a>(_name_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an exception.  <a href="#a3a605647d641eb5c21f5ae634bfcda50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a747135512a3c049df4148cf132f8da1c">E4C_DEFINE_EXCEPTION</a>(_name_, _message_, _super_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an exception.  <a href="#a747135512a3c049df4148cf132f8da1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ab971b1b935713b932a32cee525223c4d">E4C_SIGNAL_MAPPING</a>(_signal_number_, _exception_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signal mapping literal.  <a href="#ab971b1b935713b932a32cee525223c4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ad9a799b298c1f39c427364bfc7bfb230">E4C_NULL_SIGNAL_MAPPING</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a null signal mapping literal.  <a href="#ad9a799b298c1f39c427364bfc7bfb230"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532">e4c_uncaught_handler</a> )(const <a class="el" href="structe4c__exception.html">e4c_exception</a> *exception)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the signature of a function which will be executed in the event of an uncaught exception.  <a href="#a06e18483913c9112424bc941e248a532"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50">e4c_status</a> { <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50ad78680d90dc3a7e42da9f2eb2ff8e4c9">e4c_succeeded</a>, 
<a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a8d27c3fe156c5e88b8927a45a99903c8">e4c_recovered</a>, 
<a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a3e25fc733de62745054a380444ada211">e4c_failed</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Represents the completeness of a code block aware of exceptions. </p>
 <a href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exception context handling Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions enclose the scope of the exception handling system and retrieve the current exception context.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a64b5cdb24278ff07e6f7767b68890473">e4c_context_is_ready</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current exception context is ready.  <a href="#a64b5cdb24278ff07e6f7767b68890473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4">e4c_context_begin</a> (bool handle_signals, <a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532">e4c_uncaught_handler</a> uncaught_handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an exception context.  <a href="#aa27dd8be022e5734c0081dcb0e0065c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74">e4c_context_end</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current exception context.  <a href="#a7fbe6fb51b19a6485f806c006711ec74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f">e4c_context_set_signal_mappings</a> (const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a> *mappings)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the specified signal mappings to the exception context.  <a href="#a8a4c54a4d7cd10568b639749e8ec0e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df">e4c_context_get_signal_mappings</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the signal mappings for the current exception context.  <a href="#a7290cbfb8abb0b2ecf338cdb4de5d6df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50">e4c_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26">e4c_get_status</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the completeness status of the executing code block.  <a href="#a961e9d117c98424796ae769f2b2e6b26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d">e4c_get_exception</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exception that was thrown.  <a href="#ab67ff2dbcdda36ef766b096e7198614d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Other integration and convenience functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ac84af6b4e6798e3cc98de0012dcacb7f">e4c_library_version</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the library version number.  <a href="#ac84af6b4e6798e3cc98de0012dcacb7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1">e4c_is_instance_of</a> (const <a class="el" href="structe4c__exception.html">e4c_exception</a> *instance, const <a class="el" href="structe4c__exception.html">e4c_exception</a> *type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an exception is of a given exception type.  <a href="#a8a2d5f174246ce4750c54c60ccd0b3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ad129f3e99e1483f691c8f3134f85740b">e4c_print_exception</a> (const <a class="el" href="structe4c__exception.html">e4c_exception</a> *exception)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a fatal error message regarding the specified exception.  <a href="#ad129f3e99e1483f691c8f3134f85740b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined signal mappings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>There is a predefined set of signal mappings. Signal mappings are used to convert signals into exceptions. </p>
<p>Common signals are mapped to its corresponding exception, for example: </p>
<ul>
<li>
<code>SIGABRT</code> is mapped to <code><a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a" title="This exception is thrown to abort the process.">AbortException</a></code> </li>
<li>
<code>SIGFPE</code> is mapped to <code><a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a" title="This exception is thrown when the process performs an erroneous arithmetic operation.">ArithmeticException</a></code> </li>
<li>
<code>SIGSEGV</code> is mapped to <code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> </li>
<li>
<code>SIGTERM</code> is mapped to <code><a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4" title="This exception is thrown to request the termination of the process.">TerminationException</a></code> </li>
<li>
...and so on </li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df" title="Retrieves the signal mappings for the current exception context.">e4c_context_get_signal_mappings</a> </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a777634d452ce83a6b7cd697c00f7f98b">e4c_default_signal_mappings</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of predefined signal mappings.  <a href="#a777634d452ce83a6b7cd697c00f7f98b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined exceptions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Built-in exceptions represent usual error conditions that might occur during the course of any program. </p>
<p>They are organized into a <em>pseudo-hierarchy</em>, being <code><a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a></code> the common <em>supertype</em> of all exceptions.  </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96">RuntimeException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the root of the exception pseudo-hierarchy.  <a href="#a25ac8ed644959c0a02ba27134f1d9d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ab79c3dc39a4ab647e41f0f76f3d1193a">NotEnoughMemoryException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the system runs out of memory.  <a href="#ab79c3dc39a4ab647e41f0f76f3d1193a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#aab3e04a700f83bd01ca51ccc94ba423e">NullPointerException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when an unexpected null pointer is found.  <a href="#aab3e04a700f83bd01ca51ccc94ba423e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#adb9736e478b9bdc3519186553cbe56a3">AssertionException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when an assertion does not hold.  <a href="#adb9736e478b9bdc3519186553cbe56a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a317656b402c05741fff856f543b1b37b">FileOpenException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when a file cannot be opened.  <a href="#a317656b402c05741fff856f543b1b37b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ad3235203c55e60e7b54884d55d06b6be">SignalException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is the common supertype of all signal exceptions.  <a href="#ad3235203c55e60e7b54884d55d06b6be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a56bb6ac49648349341b8356449fa89c3">SignalAlarmException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when a time limit has elapsed.  <a href="#a56bb6ac49648349341b8356449fa89c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a77deb38475061aa2dc40f705b7c40757">SignalChildException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when a child process terminates.  <a href="#a77deb38475061aa2dc40f705b7c40757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a4c6b68584333142345acb7739a11e062">SignalTrapException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when a condition arises that a debugger has requested to be informed of.  <a href="#a4c6b68584333142345acb7739a11e062"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#abafe7605b8224c9e5a25942b1b0ab9aa">ErrorSignalException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is the common supertype of all error signal exceptions.  <a href="#abafe7605b8224c9e5a25942b1b0ab9aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a260dfb8d4895201858c3a21669e7f7fe">IllegalInstructionException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process attempts to execute an illegal instruction.  <a href="#a260dfb8d4895201858c3a21669e7f7fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a">ArithmeticException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process performs an erroneous arithmetic operation.  <a href="#ad4d56dfb22dbc20780a5c59eed3a8a7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea">BadPointerException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process tries to dereference an invalid pointer.  <a href="#a6a9181ab0bdb1efc34d23bc5d14b02ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a0ee8ec58c2f81654cba3f12d39c2e56d">BrokenPipeException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process attempts to write to a broken pipe.  <a href="#a0ee8ec58c2f81654cba3f12d39c2e56d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ac45033fa26fa228758f1ede8c6b60075">ControlSignalException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is the common supertype of all control signal exceptions.  <a href="#ac45033fa26fa228758f1ede8c6b60075"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ae242b32036329b4b0f16b6794649a1ea">StopException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown to stop the process for later resumption.  <a href="#ae242b32036329b4b0f16b6794649a1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a0e007f369ee872435c3b0d78b1516fde">KillException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown to terminate the process immediately.  <a href="#a0e007f369ee872435c3b0d78b1516fde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a47ce40cb05abc6376957d7360aab59f0">HangUpException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process' terminal is closed.  <a href="#a47ce40cb05abc6376957d7360aab59f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4">TerminationException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown to request the termination of the process.  <a href="#a36ea459589195777a0189a5edf0983f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a">AbortException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown to abort the process.  <a href="#a37904193f6aa65881e748ea0e25d1b5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a5ed1159dd09385426e59765b04a90734">CPUTimeException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the process has used up the CPU for too long.  <a href="#a5ed1159dd09385426e59765b04a90734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88">UserControlSignalException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is the common supertype of all control signal exceptions caused by the user.  <a href="#ac26e60f7bb642461cb3f23b8ce145d88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3">UserQuitException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the user requests to quit the process.  <a href="#a92585d836747d936952588b32e2cefc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683">UserInterruptionException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when the user requests to interrupt the process.  <a href="#a31d8bf96d228e4a541608223a4d95683"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e">UserBreakException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when a user wishes to break the process.  <a href="#a229491b9c8a862e76a7fe13fa909900e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a0e66c61e5b993b919795f5882d0f2623">ProgramSignalException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is the common supertype of all user-defined signal exceptions.  <a href="#a0e66c61e5b993b919795f5882d0f2623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#ada0f3c6dc452cbf6f7d8b134f0d46a2a">ProgramSignal1Exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when user-defined conditions occur.  <a href="#ada0f3c6dc452cbf6f7d8b134f0d46a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structe4c__exception.html">e4c_exception</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="e4c_8h.html#a199dabf2a99ead7e9b904bf739a84196">ProgramSignal2Exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when user-defined conditions occur.  <a href="#a199dabf2a99ead7e9b904bf739a84196"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>exceptions4c header file </p>
<dl class="version"><dt><b>Version:</b></dt><dd>2.3 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Copyright (c) 2010 Guillermo Calvo</dd></dl>
<h2><a class="anchor" id="e4c_h"></a>
exceptions4c header file</h2>
<p>This header file needs to be included from in order to be able to use any of the keywords of the the exception handling system: </p>
<ul>
<li>
<code>try</code> </li>
<li>
<code>catch</code> </li>
<li>
<code>finally</code> </li>
<li>
<code>throw</code> </li>
<li>
<code>with</code> </li>
<li>
<code>using</code> </li>
</ul>
<p>In order to stop defining this keywords, there exists a <code>E4C_NOKEYWORDS</code> <em>compile-time</em> parameter. When the keywords are not defined, the next set of alternative macros can be used to achieve the same functionality: </p>
<ul>
<li>
<code>E4C_TRY</code> </li>
<li>
<code>E4C_CATCH</code> </li>
<li>
<code>E4C_FINALLY</code> </li>
<li>
<code>E4C_THROW</code> </li>
<li>
<code>E4C_WITH</code> </li>
<li>
<code>E4C_USING</code> </li>
</ul>
<h2><a class="anchor" id="license"></a>
License</h2>
<p>This is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this software. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a298c59325609e266f86aad4f31899026"></a><!-- doxytag: member="e4c.h::catch" ref="a298c59325609e266f86aad4f31899026" args="(_exception_type_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define catch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_type_&#160;)</td>
          <td>&#160;&#160;&#160;E4C_CATCH(_exception_type_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Introduces a block of code capable of handling a specific kind of exceptions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_exception_type_</td><td>The type of exceptions to be handled</td></tr>
  </table>
  </dd>
</dl>
<p><code>catch</code> blocks are optional code blocks that must be preceded by <code>try</code>, <code>with/use</code> or <code>using</code> blocks. Several <code>catch</code> blocks can be placed next to one another. </p>
<p>When an exception is thrown from a <code>try</code> block, the system looks for a <code>catch</code> block to handle it. The first capable block (in order of appearance) will be executed and the exception is said to be <em>caught</em>. </p>
<p>The caught exception can be accessed through the function <code>e4c_get_exception</code>. </p>
<p>If a <code>catch</code> block handles (at <em>compile-time</em>) a generic type of exceptions, the specific type of the actual exception can be determined (at <em>run-time</em>) by comparing the <code>type</code> of the caught exception against the type of another exceptions previously defined in the program. </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a>(<a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a>){
    const <a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> * exception = <a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception()</a>;
    if(exception-&gt;type == SignalException.type){
        ...
    }else if(exception-&gt;type == NotEnoughMemoryException.type){
        ...
    }
 }
 </pre><p>However, this check compares the exception against a specific type. So, if the thrown exception was a <em>subtype</em> of the given exception type, this comparison would then yield <code>false</code>. For example, in the previous example, if the thrown exception was of type <code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code>: it would be caught by the <code>catch</code> block, because an instance of a <code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> is also an instance of a <code><a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a></code>, but the comparison <code>(exception-&gt;type == SignalException.type)</code> would yield <code>false</code> because the type of the thrown exception was not <em>strictly speaking</em> <code><a class="el" href="e4c_8h.html#ad3235203c55e60e7b54884d55d06b6be" title="This exception is the common supertype of all signal exceptions.">SignalException</a></code>, but <code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code>. </p>
<p>There is a more powerful way to find out if the thrown exception <b>is an instance of</b> a given type of exception <em>or any subtype</em>. The function <code><a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1" title="Returns whether an exception is of a given exception type.">e4c_is_instance_of</a></code> can determines that: </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a>(<a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a>){
    const <a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> * exception = <a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception()</a>;
    if( <a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1" title="Returns whether an exception is of a given exception type.">e4c_is_instance_of</a>(exception, SignalException.type) ){
        ...
    }else if(exception-&gt;type == NotEnoughMemoryException.type){
        ...
    }
 }
 </pre><p>In this example, the <code>if</code> condition would evaluate to <code>true</code> because a <code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> <b>is an instance of a</b> <code><a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a></code>. </p>
<p>After the <code>catch</code> block completes, the <code>finally</code> block (if any) is executed. Then the program continues with the next line following the set of <code>try/catch/finally</code> blocks. </p>
<p>However, if an exception is thrown in a <code>catch</code> block, then the <code>finally</code> will be executed right away and the system will look for an outter <code>catch</code> block to handle it. </p>
<p>Only one of all the <code>catch</code> blocks will be executed for each <code>try</code> block, even though the executed <code>catch</code> block throws another exception. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a375b90620a57f874e38fdf35ed713b6a"></a><!-- doxytag: member="e4c.h::e4c_assert" ref="a375b90620a57f874e38fdf35ed713b6a" args="(_condition_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_condition_&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_ASSERT(_condition_)
</pre></div>
<p>Expresses a program assertion. </p>
<p>An assertion is a mechanism to express that the developer <em>thinks</em> that a specific condition is always met at some point of the program. </p>
<p><code>e4c_assert</code> is a convenient way to insert debugging assertions into a program. The <code>NDEBUG</code> <em>compile-time</em> parameter determines whether the assumptions will be actually verified by the program at <em>run-time</em>. </p>
<p>In absence of <code>NDEBUG</code>, the assertion statements will be ignored and therefore will have no effect on the program, not even evaluating the condition. Therefore expressions passed to <code>e4c_assert</code> must not contain side-effects, since they will not happen when debugging is disabled. </p>
<p>In presence of <code>NDEBUG</code>, the assertion statements will verify that the condition is met every time the program reaches that point of the program. </p>
<p>If the assertion does not hold at any time, then an <code>AssertionException</code> will be thrown to indicate the programming error. This exception cannot be caught whatsoever. The program (or current thread) will be terminated. </p>
<p>The main advantage of using this assertion mechanism (as opposed to the macros provided by the standard header file <code>assert.h</code>) is that before actually exiting the program or thread, all of the pending <code>finally</code> blocks will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_condition_</td><td>A predicate that must evaluate to <code>true</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#adb9736e478b9bdc3519186553cbe56a3" title="This exception is thrown when an assertion does not hold.">AssertionException</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a605647d641eb5c21f5ae634bfcda50"></a><!-- doxytag: member="e4c.h::E4C_DECLARE_EXCEPTION" ref="a3a605647d641eb5c21f5ae634bfcda50" args="(_name_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_DECLARE_EXCEPTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name_&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_DECLARE_EXCEPTION(_name_)
</pre></div>
<p>Declares an exception. </p>
<p>This macro introduces the name of an <code>extern</code>, <code>const</code> exception which will be available to be thrown or caught. It is only a <em>declaration</em> (i.e. the exception has to be <em>defined</em> somewhere else). This macro is intended to be used inside a header file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_name_</td><td>Name of the new exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a747135512a3c049df4148cf132f8da1c" title="Defines an exception.">E4C_DEFINE_EXCEPTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a747135512a3c049df4148cf132f8da1c"></a><!-- doxytag: member="e4c.h::E4C_DEFINE_EXCEPTION" ref="a747135512a3c049df4148cf132f8da1c" args="(_name_, _message_, _super_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_DEFINE_EXCEPTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_message_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_super_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_DEFINE_EXCEPTION(_name_, _message_, _super_)
</pre></div>
<p>Defines an exception. </p>
<p>This macro allocates a new, <code>const</code> exception. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_name_</td><td>Name of the new exception </td></tr>
    <tr><td class="paramname">_message_</td><td>Default message of the new exception </td></tr>
    <tr><td class="paramname">_super_</td><td>Supertype of the new exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a3a605647d641eb5c21f5ae634bfcda50" title="Declares an exception.">E4C_DECLARE_EXCEPTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a221e306037ef73b1788ddd261088230f"></a><!-- doxytag: member="e4c.h::E4C_EXCEPTION_MESSAGE_SIZE" ref="a221e306037ef73b1788ddd261088230f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_EXCEPTION_MESSAGE_SIZE&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides the maximum length (in bytes) of an exception message. </p>

</div>
</div>
<a class="anchor" id="ad9a799b298c1f39c427364bfc7bfb230"></a><!-- doxytag: member="e4c.h::E4C_NULL_SIGNAL_MAPPING" ref="ad9a799b298c1f39c427364bfc7bfb230" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_NULL_SIGNAL_MAPPING</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_NULL_SIGNAL_MAPPING
</pre></div>
<p>Represents a null signal mapping literal. </p>
<p>This macro comes in handy for terminating arrays of <code><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a></code>s. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df" title="Retrieves the signal mappings for the current exception context.">e4c_context_get_signal_mappings</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a3a605647d641eb5c21f5ae634bfcda50" title="Declares an exception.">E4C_DECLARE_EXCEPTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1746d33d024fbe62d6edf60113d2001"></a><!-- doxytag: member="e4c.h::e4c_reusing_context" ref="ac1746d33d024fbe62d6edf60113d2001" args="(_thrown_exception_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_reusing_context</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_thrown_exception_&#160;)</td>
          <td>&#160;&#160;&#160;_E4C_REUSING_CONTEXT(_thrown_exception_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reuses an existing exception context, otherwise, begins a new one and then ends it. </p>
<p>This macro lets library developers use the exception framework, regardless of whether the library clients are unaware of the exception handling system. In a nutshell, function libraries can use <code><a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a></code>, <code><a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a></code>, <code><a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw</a></code>, etc. whether the client previously began an exception context or not. </p>
<p>You <b>must not use this macro</b> unless you are implementing some functionality which is to be called from another program, potentially unaware of exceptions. </p>
<p>A block introduced by <code>e4c_reusing_context</code> is guaranteed to take place <em>inside</em> an execution context. When the block completes, the system returns to its previous status (if it was necessary to open a new exception context, it will be automatically closed). </p>
<p>This way, when an external functions encounters an error, it may either throw an exception (when the caller is aware of the exception system), or otherwise return an error code (when the caller did not open an exception context). </p>
<p><code>e4c_reusing_context</code> needs to be given a variable that will point to whichever exception thrown inside the block. This variable must be a pointer to <code><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a></code> and will be set to <code>NULL</code> if no exception was thrown inside the block. </p>
<pre class="fragment">
 int library_public_function(void * pointer, int number){
 &#160;
     /<span>*
     We don't know where this function is going to be called from, so:
       * We cannot use "try", "throw", etc. right here, because the exception
       context COULD be uninitialized at this very moment.
       * We cannot call "e4c_context_begin" either, because the
       exception context COULD be already initialized.
     If we have to make use of the exception handling system, we need to
     "reuse" the existing exception context or "use" a new one.
     *</span>/
 &#160;
     <a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> * exception;
 &#160;
     <a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context(exception)</a>{
         /<span>* Now we can safely use "try", "throw", etc. *</span>/
         if(pointer == NULL){
             <a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw(NullPointerException)</a>;
         }
 &#160;
         library_private_function(pointer, number);
     }
 &#160;
     if(exception != NULL){
         /<span>*
         We got here because:
           * There was no exception context
           * An exception was caught during the execution of the block
           * The block was closed
         Now we should return an error code to the caller, which is unaware of
         the exception system (if the caller was aware, the exception would
         have been simply propagated).
         *</span>/
 &#160;
         if(exception-&gt;type == <a class="el" href="e4c_8h.html#aab3e04a700f83bd01ca51ccc94ba423e" title="This exception is thrown when an unexpected null pointer is found.">NullPointerException</a>){
             return(-3);
         }else if(exception-&gt;type == <a class="el" href="e4c_8h.html#ab79c3dc39a4ab647e41f0f76f3d1193a" title="This exception is thrown when the system runs out of memory.">NotEnoughMemoryException</a>){
             return(-2);
         }
         return(-1);
     }
 &#160;
     /<span>*
     If we got here, it means that our block completed successfully.
     We need to return a "success" status code.
     *</span>/
     return(0);
 }
 </pre><p>Next, the semantics of <code>e4c_reusing_context</code> are explained, step by step. </p>
<ul>
<li>
If there is an exception context at the time the block starts: <ol>
<li>
The existing exception context will be reused. </li>
<li>
The code block will take place. </li>
<li>
If any exception is thrown during the execution of the block: <ul>
<li>
It will be <b>propagated</b> upwards to the caller. </li>
<li>
The control will be transferred to the nearest surrounding block of code which is able to handle that exception. </li>
</ul>
</li>
<li>
When the block ends: <ul>
<li>
The block completed successfully. </li>
<li>
<code>_thrown_exception_</code> will be <code>NULL</code>. </li>
<li>
The function may then return a "success" status code. </li>
</ul>
</li>
</ol>
</li>
<li>
If there is no exception context at the time the block starts: <ol>
<li>
A new exception context will be begun; note that the signal handling system <b>will NOT be set up.</b>. </li>
<li>
The code block will take place. </li>
<li>
If any exception is thrown during the execution of the block: <ul>
<li>
It will be <b>caught</b> and <code>_thrown_exception_</code> will point to it. </li>
</ul>
</li>
<li>
When the block ends: <ul>
<li>
If <code>_thrown_exception_</code> is <code>NULL</code> then the block completed successfully. The function may then return a "success" status code. </li>
<li>
Otherwise, an exception was thrown during the execution of the block. The function may then return an error code to the caller.  </li>
</ul>
</li>
</ol>
</li>
</ul>
<p>If you need to perform any cleanup, you should place it <em>inside</em> a <code>finally</code> block, for example: </p>
<pre class="fragment">
 ...
 <a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context(exception)</a>{
 &#160;
     void * buffer = NULL;
     <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
         buffer = malloc(1024);
         ...
     }<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a>{
         free(buffer);
     }
 }
 ...
 </pre><p>If you need to rely on the signal handling system, you may call <code><a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a></code> explicitely. You must take into account that you could be <em>hijacking</em> your client's original signal mappings, so you should also call <code><a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df" title="Retrieves the signal mappings for the current exception context.">e4c_context_get_signal_mappings</a></code> in order to restore the previous signal mappings when you are done. </p>
<pre class="fragment">
 const <a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> new_mappings[] = {
     <a class="el" href="e4c_8h.html#ab971b1b935713b932a32cee525223c4d" title="Represents a signal mapping literal.">E4C_SIGNAL_MAPPING(SIGABRT, Exception1)</a>,
     <a class="el" href="e4c_8h.html#ab971b1b935713b932a32cee525223c4d" title="Represents a signal mapping literal.">E4C_SIGNAL_MAPPING(SIGINT, Exception2)</a>,
     ...
     <a class="el" href="e4c_8h.html#ad9a799b298c1f39c427364bfc7bfb230" title="Represents a null signal mapping literal.">E4C_NULL_SIGNAL_MAPPING</a>
 };
 ...
 <a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context(exception)</a>{
 &#160;
     const <a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> * old_mappings = <a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df" title="Retrieves the signal mappings for the current exception context.">e4c_context_get_signal_mappings()</a>;
 &#160;
     <a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a> (new_mappings);
 &#160;
     <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
         ...
     }<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a>{
         <a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a> (old_mappings);
     }
 }
 ...
 </pre><p>This macro only begins a new exception context <b>if there is no one, already begun, to be used</b> whereas <code><a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a></code> always attempts to begin a new one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_thrown_exception_</td><td>A reference to the exception that was thrown inside the block (if any), <code>NULL</code> otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a64b5cdb24278ff07e6f7767b68890473" title="Checks if the current exception context is ready.">e4c_context_is_ready</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a> </dd>
<dd>
<a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab971b1b935713b932a32cee525223c4d"></a><!-- doxytag: member="e4c.h::E4C_SIGNAL_MAPPING" ref="ab971b1b935713b932a32cee525223c4d" args="(_signal_number_, _exception_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_SIGNAL_MAPPING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_signal_number_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_SIGNAL_MAPPING(_signal_number_, _exception_)
</pre></div>
<p>Represents a signal mapping literal. </p>
<p>This macro comes in handy for initializing arrays of <code><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a></code>s. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_signal_number_</td><td>Numeric value of the signal to be converted </td></tr>
    <tr><td class="paramname">_exception_</td><td>Exception representing the signal</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7290cbfb8abb0b2ecf338cdb4de5d6df" title="Retrieves the signal mappings for the current exception context.">e4c_context_get_signal_mappings</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a3a605647d641eb5c21f5ae634bfcda50" title="Declares an exception.">E4C_DECLARE_EXCEPTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7851c828f2a8203c99eb81fe8f9a2e37"></a><!-- doxytag: member="e4c.h::e4c_using_context" ref="a7851c828f2a8203c99eb81fe8f9a2e37" args="(_handle_signals_, _uncaught_handler_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_using_context</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_handle_signals_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_uncaught_handler_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_E4C_USING_CONTEXT(_handle_signals_, _uncaught_handler_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Introduces a block of code which will use a new exception context. </p>
<p>This macro begins a new exception context to be used by the code block right next to it. When the code completes, <code><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a></code> will be called implicitly. </p>
<p>This macro is very convenient when the beginning and the ending of the current exception context are next to each other. For example, there is no semantic difference between this two blocks of code: </p>
<pre class="fragment">
 &#160;
 /<span>* block 1 *</span>/
 <a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> (e4c_true, NULL);
 /<span>* ... *</span>/
 <a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end()</a>;
 &#160;
 /<span>* block 2 *</span>/
 <a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context(e4c_true, NULL)</a>{
     /<span>* ... *</span>/
 }
 </pre><p>This macro <b>always</b> attempts to begin a new exception context, whereas <code><a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context</a></code> only does if there is no exception context, already begun, to be used. </p>
<p>This macro <b>should be used whenever possible</b>, rather than doing the explicit, manual calls to <code><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a></code> and <code><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a></code>, because it is less prone to errors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_handle_signals_</td><td>If <code>true</code>, the signal handling system will be set up with the default mapping. </td></tr>
    <tr><td class="paramname">_uncaught_handler_</td><td>If not <code>NULL</code>, this function will be called in the event of an uncaught exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aadb996e59894bfeec035af1b8ca0547f"></a><!-- doxytag: member="e4c.h::e4c_using_file" ref="aadb996e59894bfeec035af1b8ca0547f" args="(_file_, _path_, _mode_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_using_file</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_file_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_path_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mode_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="e4c_8h.html#a17b01b3e04b99590d572db88feca7479" title="Introduces a block of code with automatic disposal of a resource and acquisition, preventing null poi...">e4c_using_if_not_null</a>( file, _file_, (_path_, _mode_), \
    FileOpenException, <span class="stringliteral">&quot;Could not open file: &quot;</span> #_path_)
</pre></div>
<p>Introduces a block of code with automatic acquisition and disposal of a file stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_file_</td><td>The file to be acquired, used and then disposed </td></tr>
    <tr><td class="paramname">_path_</td><td>The path of the file to be opened </td></tr>
    <tr><td class="paramname">_mode_</td><td>The access mode for the file</td></tr>
  </table>
  </dd>
</dl>
<p>This macro lets you acquire and dispose (open and close) files according to the <em>dispose pattern</em>: </p>
<pre class="fragment">
 FILE * file;
 &#160;
 <a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f" title="Introduces a block of code with automatic acquisition and disposal of a file stream.">e4c_using_file</a>(file, "log.txt", "a"){
     /<span>* implicit: file = fopen("log.txt", "a"); *</span>/
     fputs("hello, world!\n", file);
     /<span>* implicit: fclose(file); *</span>/
 }
 </pre><p>If <code>fopen</code> returns <code>NULL</code> then the exception <code>FileOpenException</code> will be automatically thrown. </p>
<p>The specific cause of the error can be determined by checking the <code>error_number</code> of the thrown exception (it captures the value of <code>errno</code>).  </p>

</div>
</div>
<a class="anchor" id="ac267831edf6e221dd463f56f02fa4561"></a><!-- doxytag: member="e4c.h::e4c_using_if" ref="ac267831edf6e221dd463f56f02fa4561" args="(_type_, _resource_, _args_, _cond_, _exception_, _msg_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_using_if</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_resource_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_args_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_cond_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_msg_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">E4C_WITH(_resource_, e4c_dispose_##_type_){ \
    _resource_ = e4c_acquire_##_type_ _args_; \
    <span class="keywordflow">if</span>( !(_cond_) ) E4C_THROW(_exception_, _msg_); \
  }E4C_USE
</pre></div>
<p>Introduces a block of code with automatic disposal of a resource and acquisition, under certain condition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_type_</td><td>The type of the resource </td></tr>
    <tr><td class="paramname">_resource_</td><td>The resource to be acquired, used and then disposed </td></tr>
    <tr><td class="paramname">_args_</td><td>A list of arguments to be passed to the acquisition function </td></tr>
    <tr><td class="paramname">_cond_</td><td>The condition which has to be satisfied in order to consider the acquisition <em>complete</em> </td></tr>
    <tr><td class="paramname">_exception_</td><td>The exception to be thrown if the acquisition function does not satisfy the specified condition </td></tr>
    <tr><td class="paramname">_msg_</td><td>The exception message</td></tr>
  </table>
  </dd>
</dl>
<p>This macro will attempt the acquisition of the resource and then will check the given condition. If the condition evaluates to false, then the specified exception will be thrown, and therefore, the disposal of the resource will not take place. </p>
<p>This is a convenience macro for reusing legacy C standard functions which don't throw exceptions when the acquisition fails. For example: </p>
<pre class="fragment">
 # define e4c_acquire_memory malloc
 # define e4c_dispose_memory(_memory_, _failed_) free(_memory_)
 # define <a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa" title="Introduces a block of code with automatic acquisition and disposal of a memory buffer.">e4c_using_memory(_resource_, _bytes_)</a> \
          <a class="el" href="e4c_8h.html#ac267831edf6e221dd463f56f02fa4561" title="Introduces a block of code with automatic disposal of a resource and acquisition, under certain condi...">e4c_using_if</a>(memory, _resource_, ( _bytes_ ), _resource_ != NULL, \
          <a class="el" href="e4c_8h.html#ab79c3dc39a4ab647e41f0f76f3d1193a" title="This exception is thrown when the system runs out of memory.">NotEnoughMemoryException</a> )
 </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a4099c93334aae15414f9f91f11fecb8d" title="Introduces a block of code with automatic acquisition and disposal of a resource.">using</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17b01b3e04b99590d572db88feca7479"></a><!-- doxytag: member="e4c.h::e4c_using_if_not_null" ref="a17b01b3e04b99590d572db88feca7479" args="(_type_, _resource_, _args_, _exception_, _msg_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_using_if_not_null</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_resource_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_args_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_msg_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="e4c_8h.html#ac267831edf6e221dd463f56f02fa4561" title="Introduces a block of code with automatic disposal of a resource and acquisition, under certain condi...">e4c_using_if</a>(_type_, _resource_, _args_, _resource_ != NULL, \
    _exception_, _msg_)
</pre></div>
<p>Introduces a block of code with automatic disposal of a resource and acquisition, preventing null pointers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_type_</td><td>The type of the resource </td></tr>
    <tr><td class="paramname">_resource_</td><td>The resource to be acquired, used and then disposed </td></tr>
    <tr><td class="paramname">_args_</td><td>A list of arguments to be passed to the acquisition function </td></tr>
    <tr><td class="paramname">_exception_</td><td>The exception to be thrown if the acquisition function yields a <code>NULL</code> pointer </td></tr>
    <tr><td class="paramname">_msg_</td><td>The exception message</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#ac267831edf6e221dd463f56f02fa4561" title="Introduces a block of code with automatic disposal of a resource and acquisition, under certain condi...">e4c_using_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9d90ec6662db343293a3cabad26caa"></a><!-- doxytag: member="e4c.h::e4c_using_memory" ref="a9f9d90ec6662db343293a3cabad26caa" args="(_buffer_, _bytes_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define e4c_using_memory</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_buffer_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_bytes_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="e4c_8h.html#a17b01b3e04b99590d572db88feca7479" title="Introduces a block of code with automatic disposal of a resource and acquisition, preventing null poi...">e4c_using_if_not_null</a>(memory, _buffer_, (_bytes_), \
  NotEnoughMemoryException, <span class="stringliteral">&quot;Could not allocate memory for &#39;&quot;</span> #_buffer_ <span class="stringliteral">&quot;&#39;.&quot;</span>)
</pre></div>
<p>Introduces a block of code with automatic acquisition and disposal of a memory buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_buffer_</td><td>The buffer to be acquired, used and then disposed </td></tr>
    <tr><td class="paramname">_bytes_</td><td>The amount of memory to be allocated (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<p>This macro lets you acquire and dispose memory according to the <em>dispose pattern</em>: </p>
<pre class="fragment">
 void * buffer;
 &#160;
 <a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa" title="Introduces a block of code with automatic acquisition and disposal of a memory buffer.">e4c_using_memory(buffer, 1024)</a>{
     /<span>* implicit: buffer = malloc(1024); *</span>/
     memset(buffer, 0, 1024);
     /<span>* implicit: free(buffer); *</span>/
 }
 </pre><p>If <code>malloc</code> returns <code>NULL</code> then the exception <code>NotEnoughMemoryException</code> will be automatically thrown.  </p>

</div>
</div>
<a class="anchor" id="a890f79613092dcd580078ff46babfb6e"></a><!-- doxytag: member="e4c.h::E4C_VERSION_MAJOR" ref="a890f79613092dcd580078ff46babfb6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_MAJOR</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_VERSION(_E4C_V_MAJOR)
</pre></div>
<p>Provides the library major version number. </p>
<p>The library major version number is an <code>int</code> value which is incremented from one release to another when there are significant changes in functionality. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa4564247c8f8fa73e293f24e9790e2b5"></a><!-- doxytag: member="e4c.h::E4C_VERSION_MINOR" ref="aa4564247c8f8fa73e293f24e9790e2b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_MINOR</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_VERSION(_E4C_V_MINOR)
</pre></div>
<p>Provides the library minor version number. </p>
<p>The library minor version number is an <code>int</code> value which is incremented from one release to another when only minor features or significant fixes have been added. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaabdc92526a7fb8e02558867f3ad0cb8"></a><!-- doxytag: member="e4c.h::E4C_VERSION_NUMBER" ref="aaabdc92526a7fb8e02558867f3ad0cb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_NUMBER</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_VERSION(_E4C_V_NUMBER)
</pre></div>
<p>Provides the library version number. </p>
<p>The library version number is a <code>long</code> value which expresses: </p>
<ul>
<li>
library <em>thread</em> mode (either <em>single-thread</em> or <em>multi-thread</em>) </li>
<li>
library <em>major</em> version number </li>
<li>
library <em>minor</em> version number </li>
<li>
library <em>revision</em> number </li>
</ul>
<p>The multi-thread (or <em>thread-safe</em>) mode can be obtained by compiling the library with the <code>E4C_THREADSAFE</code> <em>compile-time</em> parameter. </p>
<p>The formula to encode these version numbers into a single <code>long</code> value is: </p>
<pre class="fragment">
 THREADSAFE * 10000000 + MAJOR * 1000000 + MINOR * 1000 + REVISION
 </pre> <p>These numbers can be obtained separately through the next macros: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#a28f15bc301e1a0a004040d0f2c196139" title="Provides the library thread mode (either single-thread or multi-thread)">E4C_VERSION_THREADSAFE</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a890f79613092dcd580078ff46babfb6e" title="Provides the library major version number.">E4C_VERSION_MAJOR</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#aa4564247c8f8fa73e293f24e9790e2b5" title="Provides the library minor version number.">E4C_VERSION_MINOR</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a472fdc2124dfc3fc50680cbf5811c868" title="Provides the library revision number.">E4C_VERSION_REVISION</a></code> </li>
</ul>
<p>The library version number can be also obtained as a string literal in the format "MAJOR.MINOR.REVISION (THREADSAFE)" through the <code><a class="el" href="e4c_8h.html#aea131104dcb566c9e4d134c476758b2c" title="Provides the library version number as a string literal.">E4C_VERSION_STRING</a></code> macro. </p>
<p>This version number can be considered as the <em>compile-time</em> library version number, as opposed to the <em>run-time</em> library version number (associated with the actual, compiled library). This <em>run-time</em> version number can be obtained through the <code><a class="el" href="e4c_8h.html#ac84af6b4e6798e3cc98de0012dcacb7f" title="Gets the library version number.">e4c_library_version</a></code> function. </p>
<p>The library must be compiled with the corresponding header (i.e. library version number should be equal to header version number). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#ac84af6b4e6798e3cc98de0012dcacb7f" title="Gets the library version number.">e4c_library_version</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a28f15bc301e1a0a004040d0f2c196139" title="Provides the library thread mode (either single-thread or multi-thread)">E4C_VERSION_THREADSAFE</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a890f79613092dcd580078ff46babfb6e" title="Provides the library major version number.">E4C_VERSION_MAJOR</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aa4564247c8f8fa73e293f24e9790e2b5" title="Provides the library minor version number.">E4C_VERSION_MINOR</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a472fdc2124dfc3fc50680cbf5811c868" title="Provides the library revision number.">E4C_VERSION_REVISION</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aea131104dcb566c9e4d134c476758b2c" title="Provides the library version number as a string literal.">E4C_VERSION_STRING</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a472fdc2124dfc3fc50680cbf5811c868"></a><!-- doxytag: member="e4c.h::E4C_VERSION_REVISION" ref="a472fdc2124dfc3fc50680cbf5811c868" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_REVISION</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_VERSION(_E4C_V_REVISION)
</pre></div>
<p>Provides the library revision number. </p>
<p>The library revision number is an <code>int</code> value which is incremented from one release to another when minor bugs are fixed. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea131104dcb566c9e4d134c476758b2c"></a><!-- doxytag: member="e4c.h::E4C_VERSION_STRING" ref="aea131104dcb566c9e4d134c476758b2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_STRING</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_VERSION(_E4C_V_STRING)
</pre></div>
<p>Provides the library version number as a string literal. </p>
<p>The format of the string literal is: "MAJOR.MINOR.REVISION (THREADSAFE)". </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a28f15bc301e1a0a004040d0f2c196139"></a><!-- doxytag: member="e4c.h::E4C_VERSION_THREADSAFE" ref="a28f15bc301e1a0a004040d0f2c196139" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E4C_VERSION_THREADSAFE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  _E4C_V_THREADSAFE
</pre></div>
<p>Provides the library thread mode (either single-thread or multi-thread) </p>
<p>When the library is compiled with the <code>E4C_THREADSAFE</code> <em>compile-time</em> parameter, <code>E4C_VERSION_THREADSAFE</code> will yield the <code>int</code> value <code>1</code> (meaning <em>multi-thread</em> mode), otherwise it will yield the <code>int</code> value <code>0</code> (meaning <em>single-thread</em> mode). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6f547472794c162cc629f53cd4db5454"></a><!-- doxytag: member="e4c.h::finally" ref="a6f547472794c162cc629f53cd4db5454" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define finally&#160;&#160;&#160;E4C_FINALLY</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Introduces a block of code responsible for cleaning up the previous <code>try</code> block. </p>
<p><code>finally</code> blocks are optional code blocks that must be preceded by <code>try</code>, <code>with/use</code> or <code>using</code> blocks. It is allowed to place, at most, one <code>finally</code> block. </p>
<p>The <code>finally</code> block can determine the completeness of the <code>try/catch</code> set of blocks through the function <code>e4c_get_status</code>. The thrown exception (if any) can also be accessed through the function <code>e4c_get_exception</code>. </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a>{
    switch( <a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status()</a> ){
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50ad78680d90dc3a7e42da9f2eb2ff8e4c9" title="There was no exception.">e4c_succeeded</a>:
            ...
            break;
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a8d27c3fe156c5e88b8927a45a99903c8" title="There was an exception, but it was caught.">e4c_recovered</a>:
            ...
            break;
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a3e25fc733de62745054a380444ada211" title="There was an exception and it wasn&#39;t caught.">e4c_failed</a>:
            ...
            break;
    }
 }
 </pre><p>Only one of all the <code>catch</code> blocks will be executed for each <code>try</code> block, even though the executed <code>catch</code> block throws another exception. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50" title="Represents the completeness of a code block aware of exceptions.">e4c_status</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab667a8f4f3b49bbfc2190bb01faf64fd"></a><!-- doxytag: member="e4c.h::reacquire" ref="ab667a8f4f3b49bbfc2190bb01faf64fd" args="(_max_acquire_attempts_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define reacquire</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_max_acquire_attempts_&#160;)</td>
          <td>&#160;&#160;&#160;E4C_REACQUIRE(_max_acquire_attempts_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repeats the previous E4C_WITH block entirely. </p>
<p>This macro discards any thrown exception (if any) and repeats the previous <code>with</code> block, up to a specified maximum number of attempts. If the acquisition completes, then the <code>use</code> block will be executed. </p>
<p>This macro is intended to be used in <code>catch</code> or <code>finally</code> blocks, next to a <code>with... use</code> or <code>using</code> block when the resource acquisition failed, as a quick way to fix an error condition and try to acquire the resource again. </p>
<pre class="fragment">
 image_type * image;
 const char * image_path = image_get_user_avatar();
 <a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with(image, e4c_image_dispose)</a>{
     image = e4c_image_acquire(image_path);
 }use{
     image_show(image);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(ImageNotFoundException)</a>{
     image_path = image_get_default_avatar();
     <a class="el" href="e4c_8h.html#ab667a8f4f3b49bbfc2190bb01faf64fd" title="Repeats the previous E4C_WITH block entirely.">reacquire(1)</a>;
 }
 </pre><p>If the specified maximum number of attempts is zero, then the <code>with</code> block can eventually be attempted an unlimited number of times. Care must be taken in order not to create an <em>infinite loop</em>. </p>
<p>This macro won't return control unless the <code>with</code> block has already been attempted, at least, the specified maximum number of times. </p>
<p>Once the resource has been acquired, the <code>use</code> block can also be repeated <em>alone</em> through the <code>retry</code> macro. </p>
<pre class="fragment">
 image_type * image;
 const char * image_path = image_get_user_avatar();
 display_type * display = display_get_user_screen();
 <a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with(image, e4c_image_dispose)</a>{
     image = e4c_image_acquire(image_path);
 }use{
     image_show(image, display);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(ImageNotFoundException)</a>{
     image_path = image_get_default_avatar();
     <a class="el" href="e4c_8h.html#ab667a8f4f3b49bbfc2190bb01faf64fd" title="Repeats the previous E4C_WITH block entirely.">reacquire(1)</a>;
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(DisplayException)</a>{
     display = display_get_default_screen();
     <a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4" title="Repeats the previous E4C_TRY (or E4C_USE) block entirely.">retry(1)</a>;
 }
 </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4" title="Repeats the previous E4C_TRY (or E4C_USE) block entirely.">retry</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aeda5446032a08fece73ec569b861a72c" title="Closes a block of code with automatic disposal of a resource.">use</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_max_acquire_attempts_</td><td>The maximum number of attempts to reacquire </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08cf0d726d15a42dbc3dbfe41bb45353"></a><!-- doxytag: member="e4c.h::rethrow" ref="a08cf0d726d15a42dbc3dbfe41bb45353" args="(_message_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rethrow</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_message_&#160;)</td>
          <td>&#160;&#160;&#160;E4C_RETHROW(_message_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throws again the currently thrown exception, with a new message. </p>
<p>This macro creates a new instance of the thrown exception, with a more specific message. </p>
<p><code>rethrow</code> is intended to be used in a <code>catch</code> block and the purpose is to refine the message of the currently caught exception. The previous exception (and its message) will be stored as the <em>cause</em> of the newly thrown exception. </p>
<pre class="fragment">
 try{
     image = read_file(file_path);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(FileOpenException)</a>{
     rethrow("Image not found.");
 }
 </pre><p>The semantics of this macro are the same as for the <code>throw</code> macro. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a91a9c5527cbdc3a41573c126c78a7bd9" title="Throws again the currently thrown exception, with a new, formatted message.">rethrowf</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_</td><td>The new message describing the exception. It should be more specific than the current one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91a9c5527cbdc3a41573c126c78a7bd9"></a><!-- doxytag: member="e4c.h::rethrowf" ref="a91a9c5527cbdc3a41573c126c78a7bd9" args="(_format_,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rethrowf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_format_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
    E4C_RETHROWF( (_format_), __VA_ARGS__ )
</pre></div>
<p>Throws again the currently thrown exception, with a new, formatted message. </p>
<p>This macro creates a new instance of the thrown exception, with a more specific message. </p>
<p>This is a handy way to create a new instance of the thrown exception, with a more specific, formatted message. </p>
<pre class="fragment">
 try{
     image = read_file(file_path);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(FileOpenException)</a>{
     rethrowf("Image '%s' not found.", title);
 }
 </pre><p>This macro relies on two features that were introduced in the <b>ISO/IEC 9899:1999</b> (also known as <em>C99</em>) revision of the C programming language standard in 1999: </p>
<ul>
<li>
Variadic macros </li>
<li>
Buffer-safe function <code>vsnprintf</code> </li>
</ul>
<p>In order not to create compatibility issues, this macro will only be defined when the <code>__STDC_VERSION__</code> <em>compile-time</em> parameter is defined with a value <em>greater than or equal to</em> <code>199901L</code>, or <code>HAVE_C99_VARIADIC_MACROS</code> is defined. </p>
<p>The semantics of this macro are the same as for the <code>throw</code> macro. </p>
<p>At least one argument must be passed right after the format string. The message will be composed through the function <code>vsnprintf</code> with the specified format and variadic arguments. For further information on the formatting rules, you may look up the specifications for the function <code>vsnprintf</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a08cf0d726d15a42dbc3dbfe41bb45353" title="Throws again the currently thrown exception, with a new message.">rethrow</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a9b1624a792d8464fe0958f8713b25d0c" title="Throws an exception with a formatted message.">throwf</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_format_</td><td>The string containing the specifications that determine the output format for the variadic arguments. </td></tr>
    <tr><td class="paramname">...</td><td>The variadic arguments that will be formatted according to the format control. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97c358e50b2f416cd3ce25ed983cbeb4"></a><!-- doxytag: member="e4c.h::retry" ref="a97c358e50b2f416cd3ce25ed983cbeb4" args="(_max_retry_attempts_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define retry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_max_retry_attempts_&#160;)</td>
          <td>&#160;&#160;&#160;E4C_RETRY(_max_retry_attempts_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repeats the previous E4C_TRY (or E4C_USE) block entirely. </p>
<p>This macro discards any thrown exception (if any) and repeats the previous <code>try</code> or <code>use</code> block, up to a specified maximum number of attempts. </p>
<p>This macro is intended to be used in <code>catch</code> or <code>finally</code> blocks as a quick way to fix an error condition and try again. </p>
<pre class="fragment">
 const char * file_path = config_get_user_defined_file_path();
 try{
     config = read_config(file_path);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(ConfigException)</a>{
     file_path = config_get_default_file_path();
     <a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4" title="Repeats the previous E4C_TRY (or E4C_USE) block entirely.">retry(1)</a>;
     rethrow("Wrong defaults.");
 }
 </pre><p>If the specified maximum number of attempts is zero, then the block can eventually be attempted an unlimited number of times. Care must be taken in order not to create an <em>infinite loop</em>. </p>
<p>This macro won't return control unless the block has already been attempted, at least, the specified maximum number of times. </p>
<p>At a <code>catch</code> block, the current exception is considered caught, whether the <code>retry</code> takes place or not. If you want the exception to be propagated when the maximum number of attempts has been reached, then you must (re)throw it again. </p>
<pre class="fragment">
 int dividend = 100;
 int divisor = 0;
 int result = 0;
 try{
     result = dividend / divisor;
     do_something(result);
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(RuntimeException)</a>{
     divisor = 1;
     <a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4" title="Repeats the previous E4C_TRY (or E4C_USE) block entirely.">retry(1)</a>;
     rethrow("Error (not a division by zero).");
 }
 </pre><p>At a <code>finally</code> block, the current exception (if any) will be propagated if the <code>retry</code> does not take place, so you don't need to (re)throw it again. </p>
<pre class="fragment">
 int dividend = 100;
 int divisor = 0;
 int result = 0;
 try{
     result = dividend / divisor;
     do_something(result);
 }finally{
     if( <a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status()</a> == e4c_failed ){
         divisor = 1;
         <a class="el" href="e4c_8h.html#a97c358e50b2f416cd3ce25ed983cbeb4" title="Repeats the previous E4C_TRY (or E4C_USE) block entirely.">retry(1)</a>;
         /<span>* when we get here, the exception will be propagated *</span>/
     }
 }
 </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#ab667a8f4f3b49bbfc2190bb01faf64fd" title="Repeats the previous E4C_WITH block entirely.">reacquire</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_max_retry_attempts_</td><td>The maximum number of attempts to retry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09a8a3f0ee6335f6d59ae7da4919b46e"></a><!-- doxytag: member="e4c.h::throw" ref="a09a8a3f0ee6335f6d59ae7da4919b46e" args="(_exception_type_, _message_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define throw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_message_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;E4C_THROW(_exception_type_, _message_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals an exceptional situation represented by an exception object. </p>
<p>Creates a new instance of the specified type of exception and then throws it. The provided message is copied into the thrown exception, so it can be freely deallocated. If <code>NULL</code> is passed, then the default message for that type of exception will be used. </p>
<p>When an exception is thrown, the exception handling framework looks for the appropriate <code>catch</code> block that can handle the exception. The system unwinds the call chain of the program and executes the <code>finally</code> blocks it finds. </p>
<p>When no <code>catch</code> block is able to handle an exception, the system eventually gets to the main function of the program. This situation is called an <b><em>uncaught exception</em></b>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a9b1624a792d8464fe0958f8713b25d0c" title="Throws an exception with a formatted message.">throwf</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a08cf0d726d15a42dbc3dbfe41bb45353" title="Throws again the currently thrown exception, with a new message.">rethrow</a> </dd>
<dd>
<a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532" title="This is the signature of a function which will be executed in the event of an uncaught exception...">e4c_uncaught_handler</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_exception_type_</td><td>The type of exception to be thrown </td></tr>
    <tr><td class="paramname">_message_</td><td>The <em>ad hoc</em> message describing the exception. If <code>NULL</code>, then the default message for the specified exception will be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b1624a792d8464fe0958f8713b25d0c"></a><!-- doxytag: member="e4c.h::throwf" ref="a9b1624a792d8464fe0958f8713b25d0c" args="(_exception_type_, _format_,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define throwf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_exception_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_format_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
    E4C_THROWF( (_exception_type_), (_format_), __VA_ARGS__ )
</pre></div>
<p>Throws an exception with a formatted message. </p>
<p>This is a handy way to compose a formatted message and throw an exception <em>on the fly</em>: </p>
<pre class="fragment">
 int bytes = 1024;
 void * buffer = malloc(bytes);
 if(buffer == NULL){
     throwf(NotEnoughMemoryException, "Could not allocate %d bytes.", bytes);
 }
 </pre><p>This macro relies on two features that were introduced in the <b>ISO/IEC 9899:1999</b> (also known as <em>C99</em>) revision of the C programming language standard in 1999: </p>
<ul>
<li>
Variadic macros </li>
<li>
Buffer-safe function <code>vsnprintf</code> </li>
</ul>
<p>In order not to create compatibility issues, this macro will only be defined when the <code>__STDC_VERSION__</code> <em>compile-time</em> parameter is defined with a value <em>greater than or equal to</em> <code>199901L</code>, or <code>HAVE_C99_VARIADIC_MACROS</code> is defined. </p>
<p>The semantics of this macro are the same as for the <code>throw</code> macro. </p>
<p>At least one argument must be passed right after the format string. The message will be composed through the function <code>vsnprintf</code> with the specified format and variadic arguments. For further information on the formatting rules, you may look up the specifications for the function <code>vsnprintf</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a91a9c5527cbdc3a41573c126c78a7bd9" title="Throws again the currently thrown exception, with a new, formatted message.">rethrowf</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_exception_type_</td><td>The type of exception to be thrown </td></tr>
    <tr><td class="paramname">_format_</td><td>The string containing the specifications that determine the output format for the variadic arguments. </td></tr>
    <tr><td class="paramname">...</td><td>The variadic arguments that will be formatted according to the format control. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28599e8ac99ea9faff60a2258a914aee"></a><!-- doxytag: member="e4c.h::try" ref="a28599e8ac99ea9faff60a2258a914aee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define try&#160;&#160;&#160;E4C_TRY</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Introduces a block of code aware of exceptions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeda5446032a08fece73ec569b861a72c"></a><!-- doxytag: member="e4c.h::use" ref="aeda5446032a08fece73ec569b861a72c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define use&#160;&#160;&#160;E4C_USE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a block of code with automatic disposal of a resource. </p>
<p>A <code>use</code> block must always be preceded by a <code>with</code> block. These two macros are designed so the compiler will complain about dangling <code>with</code> or <code>use</code> blocks. </p>
<p>A code block introduced by the <code>use</code> keyword will only be executed if the acquisition of the resource completes without any exception. </p>
<p>Either if the <code>use</code> block completes or not, the disposal function will be executed right away. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4099c93334aae15414f9f91f11fecb8d"></a><!-- doxytag: member="e4c.h::using" ref="a4099c93334aae15414f9f91f11fecb8d" args="(_type_, _resource_, _args_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define using</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_resource_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_args_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;E4C_USING(_type_, _resource_, _args_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Introduces a block of code with automatic acquisition and disposal of a resource. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_type_</td><td>The type of the resource </td></tr>
    <tr><td class="paramname">_resource_</td><td>The resource to be acquired, used and then disposed </td></tr>
    <tr><td class="paramname">_args_</td><td>A list of arguments to be passed to the acquisition function</td></tr>
  </table>
  </dd>
</dl>
<p>The specified resource will be acquired, used and then disposed. The automatic acquisition and disposal is achieved by calling the <em>magic</em> functions: </p>
<ul>
<li>
<code>_type_ e4c_acquire_<em>_type_</em>(_args_)</code> </li>
<li>
<code>void e4c_dispose<em>_type_</em>(_resource_, _failed_)</code> </li>
</ul>
<p>The resource will be acquired implicitly by assigning to it the result of the <em>magic</em> acquisition function <code>e4c_acquire_<em>_type_</em></code>. </p>
<p>The semantics of the automatic acquisition and disposal are the same as for blocks introduced by the keyword <code>with</code>. For example, a <code>using</code> block can also precede <code>catch</code> and <code>finally</code> blocks. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a17b01b3e04b99590d572db88feca7479" title="Introduces a block of code with automatic disposal of a resource and acquisition, preventing null poi...">e4c_using_if_not_null</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa" title="Introduces a block of code with automatic acquisition and disposal of a memory buffer.">e4c_using_memory</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f" title="Introduces a block of code with automatic acquisition and disposal of a file stream.">e4c_using_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94ef1cc39e565b84c25ca340af8d3339"></a><!-- doxytag: member="e4c.h::with" ref="a94ef1cc39e565b84c25ca340af8d3339" args="(_resource_, _dispose_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define with</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_resource_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_dispose_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;E4C_WITH(_resource_, _dispose_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a block of code with automatic disposal of a resource. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_resource_</td><td>The resource to be disposed </td></tr>
    <tr><td class="paramname">_dispose_</td><td>The name of the disposal function (or macro)</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>with</code> keyword is used to encapsulate the <em>Dispose Pattern</em>. It must be followed by the <code>use</code> keyword. </p>
<p>In addition, the <code>use</code> block can precede <code>catch</code> and <code>finally</code> blocks. </p>
<p>This pattern consists of two separate blocks and an implicit call to a given function: </p>
<ol>
<li>
the <code>with</code> block is responsible for the resource acquisition </li>
<li>
the <code>use</code> block makes use of the resource </li>
<li>
the disposal function will be called implicitly </li>
</ol>
<p>The <code>with</code> keyword guarantees that the disposal function will be called <b>if and only if</b> the acquisition block <em>completed</em> without an error (i.e. no exteption being thrown from the acquisition block). </p>
<p>If the <code>with</code> block does not complete, then neither the disposal function nor the <code>use</code> block will be ever executed. </p>
<p>The disposal function is called right after the <code>use</code> block. If an exception was thrown, the <code>catch</code> or <code>finally</code> blocks (if any) will take place <b>after</b> the disposal of the resource. </p>
<p>When called, the disposal function will receive two arguments: </p>
<ol>
<li>
The resource </li>
<li>
A boolean flag indicating if the <code>use</code> block did not <b>complete</b> </li>
</ol>
<p>This way, different actions can be taken depending on the success or failure of the block. For example, commiting or rolling back a <em>transaction</em> resource. </p>
<p>Legacy functions can be reused by defining macros. For example, a file resource needs to be closed regardless of the errors. Since the function <code>fclose</code> only takes one parameter, we could define the next macro: </p>
<pre class="fragment">
 # define e4c_dispose_file(_file_, _failed_) fclose(_file_)
 </pre><p>The typical usage of a <code><a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with</a></code> block will be: </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with(foo, e4c_dispose_foo)</a>{
     foo = e4c_acquire_foo(foobar);
     someAssertion(foo, bar);
     ...
 }<a class="el" href="e4c_8h.html#aeda5446032a08fece73ec569b861a72c" title="Closes a block of code with automatic disposal of a resource.">use</a>{
     doSomething(foo);
     ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(FooAcquisitionFailed)</a>{
     recover1();
     ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch(somethingElseFailed)</a>{
     recover2();
     ...
 }<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a>{
     cleanup();
     ...
 }
 </pre><p>Nonetheless, one-liners fit nicely too: </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a94ef1cc39e565b84c25ca340af8d3339" title="Opens a block of code with automatic disposal of a resource.">with(foo, e4c_dispose_foo)</a> foo = e4c_acquire_foo(bar, foobar); use doSomething(foo);
 </pre><p>There is a way to lighten up even more this pattern by defining convenience macros, customized for a specific kind of resources. For example, <code><a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f" title="Introduces a block of code with automatic acquisition and disposal of a file stream.">e4c_using_file</a></code> or <code><a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa" title="Introduces a block of code with automatic acquisition and disposal of a memory buffer.">e4c_using_memory</a></code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aeda5446032a08fece73ec569b861a72c" title="Closes a block of code with automatic disposal of a resource.">use</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a4099c93334aae15414f9f91f11fecb8d" title="Introduces a block of code with automatic acquisition and disposal of a resource.">using</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a17b01b3e04b99590d572db88feca7479" title="Introduces a block of code with automatic disposal of a resource and acquisition, preventing null poi...">e4c_using_if_not_null</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a9f9d90ec6662db343293a3cabad26caa" title="Introduces a block of code with automatic acquisition and disposal of a memory buffer.">e4c_using_memory</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f" title="Introduces a block of code with automatic acquisition and disposal of a file stream.">e4c_using_file</a> </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a06e18483913c9112424bc941e248a532"></a><!-- doxytag: member="e4c.h::e4c_uncaught_handler" ref="a06e18483913c9112424bc941e248a532" args=")(const e4c_exception *exception)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532">e4c_uncaught_handler</a>)(const <a class="el" href="structe4c__exception.html">e4c_exception</a> *exception)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the signature of a function which will be executed in the event of an uncaught exception. </p>
<p>These functions are not allowed to try and recover the current exception context. Moreover, the program (or current thread) will terminate right after the function returns. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exception</td><td>The uncaught exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a6cbf5662e61eccb04d74464ab3864d50"></a><!-- doxytag: member="e4c.h::e4c_status" ref="a6cbf5662e61eccb04d74464ab3864d50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50">e4c_status</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents the completeness of a code block aware of exceptions. </p>
<p>The symbolic values representing the status of a block help to distinguish between different possible situations inside a <code>finally</code> block. For example, different cleanup actions can be taken, depending on the status of the block. </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a>{
    switch( <a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status()</a> ){
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50ad78680d90dc3a7e42da9f2eb2ff8e4c9" title="There was no exception.">e4c_succeeded</a>:
            ...
            break;
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a8d27c3fe156c5e88b8927a45a99903c8" title="There was an exception, but it was caught.">e4c_recovered</a>:
            ...
            break;
 &#160;
        case <a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50a3e25fc733de62745054a380444ada211" title="There was an exception and it wasn&#39;t caught.">e4c_failed</a>:
            ...
            break;
    }
 }
 </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6cbf5662e61eccb04d74464ab3864d50ad78680d90dc3a7e42da9f2eb2ff8e4c9"></a><!-- doxytag: member="e4c_succeeded" ref="a6cbf5662e61eccb04d74464ab3864d50ad78680d90dc3a7e42da9f2eb2ff8e4c9" args="" -->e4c_succeeded</em>&nbsp;</td><td>
<p>There was no exception. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6cbf5662e61eccb04d74464ab3864d50a8d27c3fe156c5e88b8927a45a99903c8"></a><!-- doxytag: member="e4c_recovered" ref="a6cbf5662e61eccb04d74464ab3864d50a8d27c3fe156c5e88b8927a45a99903c8" args="" -->e4c_recovered</em>&nbsp;</td><td>
<p>There was an exception, but it was caught. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6cbf5662e61eccb04d74464ab3864d50a3e25fc733de62745054a380444ada211"></a><!-- doxytag: member="e4c_failed" ref="a6cbf5662e61eccb04d74464ab3864d50a3e25fc733de62745054a380444ada211" args="" -->e4c_failed</em>&nbsp;</td><td>
<p>There was an exception and it wasn't caught. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa27dd8be022e5734c0081dcb0e0065c4"></a><!-- doxytag: member="e4c.h::e4c_context_begin" ref="aa27dd8be022e5734c0081dcb0e0065c4" args="(bool handle_signals, e4c_uncaught_handler uncaught_handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void e4c_context_begin </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>handle_signals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532">e4c_uncaught_handler</a>&#160;</td>
          <td class="paramname"> <em>uncaught_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins an exception context. </p>
<p>This function begins the current exception context to be used by the program (or current thread), until <code><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a></code> is called. </p>
<p>A program (or thread) <b>must not</b> use the keywords <code><a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a></code>, <code><a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a></code>, <code><a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw</a></code>, etc. prior to calling <code>e4c_context_begin</code>. Such programming error will lead to an abrupt exit of the program or thread. </p>
<p>Calling <code>e4c_context_begin</code> <em>twice</em> is also considered a programming error, and therefore the program (or thread) will exit abruptly too. Nevertheless, <code>e4c_context_begin</code> can be called several times <em>if, and only if,</em> <code><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a></code> is called in between. </p>
<p>The signal handling system can be automatically initialized with the default signal mapping via <code>handle_signals</code> parameter when calling <code>e4c_context_begin</code>. This is equivalent to: </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a8a4c54a4d7cd10568b639749e8ec0e1f" title="Assigns the specified signal mappings to the exception context.">e4c_context_set_signal_mappings</a>(<a class="el" href="e4c_8h.html#a777634d452ce83a6b7cd697c00f7f98b" title="The array of predefined signal mappings.">e4c_default_signal_mappings</a>);
 </pre><p>Note that the behavior of <code>signal</code> is undefined in a multithreaded program, so use the signal handling system with caution. </p>
<p>In addition, a handling function can be specified to be called in the event of an uncaught exception. This function will be called before exiting the program or thread. </p>
<p>There exist a convenience function to be used as the default <em>uncaught handler</em>, called <code><a class="el" href="e4c_8h.html#ad129f3e99e1483f691c8f3134f85740b" title="Prints a fatal error message regarding the specified exception.">e4c_print_exception</a></code>. This function simply prints information regarding the exception to <code>stderr</code>, and then exits. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a64b5cdb24278ff07e6f7767b68890473" title="Checks if the current exception context is ready.">e4c_context_is_ready</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a06e18483913c9112424bc941e248a532" title="This is the signature of a function which will be executed in the event of an uncaught exception...">e4c_uncaught_handler</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ad129f3e99e1483f691c8f3134f85740b" title="Prints a fatal error message regarding the specified exception.">e4c_print_exception</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_signals</td><td>If <code>true</code>, the signal handling system will be set up with the default mapping. </td></tr>
    <tr><td class="paramname">uncaught_handler</td><td>If not <code>NULL</code>, this function will be called in the event of an uncaught exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fbe6fb51b19a6485f806c006711ec74"></a><!-- doxytag: member="e4c.h::e4c_context_end" ref="a7fbe6fb51b19a6485f806c006711ec74" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void e4c_context_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ends the current exception context. </p>
<p>This function ends the current exception context. </p>
<p>A program (or thread) <b>must</b> begin an exception context prior to calling <code>e4c_context_end</code>. Such programming error will lead to an abrupt exit of the program (or thread). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a64b5cdb24278ff07e6f7767b68890473" title="Checks if the current exception context is ready.">e4c_context_is_ready</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7290cbfb8abb0b2ecf338cdb4de5d6df"></a><!-- doxytag: member="e4c.h::e4c_context_get_signal_mappings" ref="a7290cbfb8abb0b2ecf338cdb4de5d6df" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a>* e4c_context_get_signal_mappings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the signal mappings for the current exception context. </p>
<p>This function retrieves the current array of mappings between the signals to be handled and the corresponding exception to be thrown. </p>
<p>A program (or thread) <b>must</b> begin an exception context prior to calling <code>e4c_context_get_signal_mappings</code>. Such programming error will lead to an abrupt exit of the program (or thread). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a777634d452ce83a6b7cd697c00f7f98b" title="The array of predefined signal mappings.">e4c_default_signal_mappings</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current array of mappings </dd></dl>

</div>
</div>
<a class="anchor" id="a64b5cdb24278ff07e6f7767b68890473"></a><!-- doxytag: member="e4c.h::e4c_context_is_ready" ref="a64b5cdb24278ff07e6f7767b68890473" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool e4c_context_is_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the current exception context is ready. </p>
<p>This function returns whether there is an actual exception context ready to be used by the program or current thread. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7fbe6fb51b19a6485f806c006711ec74" title="Ends the current exception context.">e4c_context_end</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ac1746d33d024fbe62d6edf60113d2001" title="Reuses an existing exception context, otherwise, begins a new one and then ends it.">e4c_reusing_context</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the current exception context of the program (or current thread) is ready to be used </dd></dl>

</div>
</div>
<a class="anchor" id="a8a4c54a4d7cd10568b639749e8ec0e1f"></a><!-- doxytag: member="e4c.h::e4c_context_set_signal_mappings" ref="a8a4c54a4d7cd10568b639749e8ec0e1f" args="(const e4c_signal_mapping *mappings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void e4c_context_set_signal_mappings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a> *&#160;</td>
          <td class="paramname"> <em>mappings</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns the specified signal mappings to the exception context. </p>
<p>This function assigns an array of mappings between the signals to be handled and the corresponding exception to be thrown. </p>
<p>A program (or thread) <b>must</b> begin an exception context prior to calling <code>e4c_context_set_signal_mappings</code>. Such programming error will lead to an abrupt exit of the program (or thread). </p>
<p>Note that the behavior of <code>signal</code> is undefined in a multithreaded program, so use the signal handling system with caution. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__signal__mapping.html" title="Represents a map between a signal and an exception.">e4c_signal_mapping</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a777634d452ce83a6b7cd697c00f7f98b" title="The array of predefined signal mappings.">e4c_default_signal_mappings</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mappings</td><td>The array of mappings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab67ff2dbcdda36ef766b096e7198614d"></a><!-- doxytag: member="e4c.h::e4c_get_exception" ref="ab67ff2dbcdda36ef766b096e7198614d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a>* e4c_get_exception </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the exception that was thrown. </p>
<p>This function returns a pointer to the exception that was thrown in the surrounding <code>try/catch/finally</code> block, if any, otherwise <code>NULL</code>. </p>
<p>A program (or thread) <b>must</b> begin an exception context prior to calling <code>e4c_get_exception</code>. Such programming error will lead to an abrupt exit of the program (or thread). </p>
<p>The function <code>e4c_is_instance_of</code> will determine if the thrown exception is an instance of any of the defined exception types. The <code>type</code> of the thrown exception can also be compared for an exact type match. </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a>(<a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a>){
    const <a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> * exception = <a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception()</a>;
    if( <a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1" title="Returns whether an exception is of a given exception type.">e4c_is_instance_of</a>(exception, SignalException.type) ){
        ...
    }else if(exception-&gt;type == NotEnoughMemoryException.type){
        ...
    }
 }
 </pre><p>The thrown exception can be obtained any time, provided that the exception context has begun at the time of the function call. However, it is sensible to call this function only during the execution of <code>finally</code> or <code>catch</code> blocks. </p>
<p>Moreover, a pointer to the thrown exception obtained <em>inside</em> a <code>finally</code> or <code>catch</code> block <b>must not</b> be used from the <em>outside</em>. </p>
<p>The exception system objects are dinamically allocated and deallocated, as the program enters or exits <code>try/catch/finally</code> blocks. While it is legal to <b>copy</b> the thrown exception and access its name and message outside these blocks, care must be taken in order not to dereference the <code>cause</code> of the exception, unless it is a <b>deep copy</b> (as opposed to a <b>shallow copy</b>). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1" title="Returns whether an exception is of a given exception type.">e4c_is_instance_of</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a09a8a3f0ee6335f6d59ae7da4919b46e" title="Signals an exceptional situation represented by an exception object.">throw</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the exception that was thrown in the current exception context (if any) otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a961e9d117c98424796ae769f2b2e6b26"></a><!-- doxytag: member="e4c.h::e4c_get_status" ref="a961e9d117c98424796ae769f2b2e6b26" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="e4c_8h.html#a6cbf5662e61eccb04d74464ab3864d50">e4c_status</a> e4c_get_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the completeness status of the executing code block. </p>
<p>Code blocks aware of exceptions have a completeness status regarding the exception handling system. This status determines whether an exception was actually thrown or not, and whether the exception was caught or not. </p>
<p>A program (or thread) <b>must</b> begin an exception context prior to calling <code>e4c_get_status</code>. Such programming error will lead to an abrupt exit of the program (or thread). </p>
<p>The status of the current block can be obtained any time, provided that the exception context has begun at the time of the function call. However, it is sensible to call this function only during the execution of <code>finally</code> blocks. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a961e9d117c98424796ae769f2b2e6b26" title="Returns the completeness status of the executing code block.">e4c_get_status</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#a6f547472794c162cc629f53cd4db5454" title="Introduces a block of code responsible for cleaning up the previous try block.">finally</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The completeness status of the executing code block </dd></dl>

</div>
</div>
<a class="anchor" id="a8a2d5f174246ce4750c54c60ccd0b3a1"></a><!-- doxytag: member="e4c.h::e4c_is_instance_of" ref="a8a2d5f174246ce4750c54c60ccd0b3a1" args="(const e4c_exception *instance, const e4c_exception *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool e4c_is_instance_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structe4c__exception.html">e4c_exception</a> *&#160;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structe4c__exception.html">e4c_exception</a> *&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether an exception is of a given exception type. </p>
<p><code>e4c_is_instance_of</code> can be used to determine if a thrown exception <b>is an instance of a given type</b> defined through <code>E4C_DEFINE_EXCEPTION</code> and/or declared through <code>E4C_DECLARE_EXCEPTION</code> </p>
<p>This macro is intended to be used in a <code>catch</code> block, or in a <code>finally</code> block provided that some exception was actually thrown (i.e. <code>e4c_get_status</code> returned <code>e4c_failed</code> or <code>e4c_recovered</code>) </p>
<pre class="fragment">
 <a class="el" href="e4c_8h.html#a28599e8ac99ea9faff60a2258a914aee" title="Introduces a block of code aware of exceptions.">try</a>{
    ...
 }<a class="el" href="e4c_8h.html#a298c59325609e266f86aad4f31899026" title="Introduces a block of code capable of handling a specific kind of exceptions.">catch</a>(<a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a>){
    const <a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> * exception = <a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception()</a>;
    if( <a class="el" href="e4c_8h.html#a8a2d5f174246ce4750c54c60ccd0b3a1" title="Returns whether an exception is of a given exception type.">e4c_is_instance_of</a>(exception, SignalException.type) ){
        ...
    }else if(exception-&gt;type == NotEnoughMemoryException.type){
        ...
    }
 }
 </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structe4c__exception.html" title="Represents an exception in the exception handling system.">e4c_exception</a> </dd>
<dd>
<a class="el" href="e4c_8h.html#ab67ff2dbcdda36ef766b096e7198614d" title="Returns the exception that was thrown.">e4c_get_exception</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The thrown exception </td></tr>
    <tr><td class="paramname">type</td><td>A previously defined type of exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the specified exception is an instance of the given type </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if either <code>instance</code> or <code>type</code> is <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac84af6b4e6798e3cc98de0012dcacb7f"></a><!-- doxytag: member="e4c.h::e4c_library_version" ref="ac84af6b4e6798e3cc98de0012dcacb7f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long e4c_library_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the library version number. </p>
<p>This function provides the same information as the <code>E4C_VERSION_NUMBER</code> macro, but the returned version number is associated with the actual, compiled library. </p>
<p>This version number can be considered as the <em>run-time</em> library version number, as opposed to the <em>compile-time</em> library version number (specified by the header file). </p>
<p>The library must be compiled with the corresponding header (i.e. library version number should be equal to header version number). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#aaabdc92526a7fb8e02558867f3ad0cb8" title="Provides the library version number.">E4C_VERSION_NUMBER</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The version number associated with the library </dd></dl>

</div>
</div>
<a class="anchor" id="ad129f3e99e1483f691c8f3134f85740b"></a><!-- doxytag: member="e4c.h::e4c_print_exception" ref="ad129f3e99e1483f691c8f3134f85740b" args="(const e4c_exception *exception)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void e4c_print_exception </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structe4c__exception.html">e4c_exception</a> *&#160;</td>
          <td class="paramname"> <em>exception</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints a fatal error message regarding the specified exception. </p>
<p>This is a convenience function for showing an error message through the standard error output. It can be passed to <code><a class="el" href="e4c_8h.html#aa27dd8be022e5734c0081dcb0e0065c4" title="Begins an exception context.">e4c_context_begin</a></code> or <code><a class="el" href="e4c_8h.html#a7851c828f2a8203c99eb81fe8f9a2e37" title="Introduces a block of code which will use a new exception context.">e4c_using_context</a></code> as the handler for uncaught exceptions. </p>
<p>In absence of <code>NDEBUG</code>, this function prints as much information regarding the exception as it is available, whereas in presence of <code>NDEBUG</code>, only the name and message of the exception are printed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exception</td><td>The uncaught exception </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if <code>exception</code> is <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a37904193f6aa65881e748ea0e25d1b5a"></a><!-- doxytag: member="e4c.h::AbortException" ref="a37904193f6aa65881e748ea0e25d1b5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a">AbortException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown to abort the process. </p>
<p>AbortException represents <code>SIGABRT</code>, the signal sent by computer programs to abort the process. </p>

</div>
</div>
<a class="anchor" id="ad4d56dfb22dbc20780a5c59eed3a8a7a"></a><!-- doxytag: member="e4c.h::ArithmeticException" ref="ad4d56dfb22dbc20780a5c59eed3a8a7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a">ArithmeticException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process performs an erroneous arithmetic operation. </p>
<p>ArithmeticException represents <code>SIGFPE</code>, the signal sent to a process when it performs an erroneous arithmetic operation. </p>

</div>
</div>
<a class="anchor" id="adb9736e478b9bdc3519186553cbe56a3"></a><!-- doxytag: member="e4c.h::AssertionException" ref="adb9736e478b9bdc3519186553cbe56a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#adb9736e478b9bdc3519186553cbe56a3">AssertionException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when an assertion does not hold. </p>
<p>This exception is part of the assertion facility of the library. It will be thrown if the <em>compile-time</em> parameter <code>NDEBUG</code> is present and the conditon of an assertion evaluates to <code>false</code>. </p>
<p>This exception cannot be caught whatsoever. The program (or current thread) will be terminated, after the execution of all pending <code>finally</code> blocks. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="e4c_8h.html#a375b90620a57f874e38fdf35ed713b6a" title="Expresses a program assertion.">e4c_assert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9181ab0bdb1efc34d23bc5d14b02ea"></a><!-- doxytag: member="e4c.h::BadPointerException" ref="a6a9181ab0bdb1efc34d23bc5d14b02ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea">BadPointerException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process tries to dereference an invalid pointer. </p>
<p>BadPointerException represents <code>SIGSEGV</code>, the signal sent to a process when it makes an invalid memory reference, or segmentation fault. </p>

</div>
</div>
<a class="anchor" id="a0ee8ec58c2f81654cba3f12d39c2e56d"></a><!-- doxytag: member="e4c.h::BrokenPipeException" ref="a0ee8ec58c2f81654cba3f12d39c2e56d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a0ee8ec58c2f81654cba3f12d39c2e56d">BrokenPipeException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process attempts to write to a broken pipe. </p>
<p>BrokenPipeException represents <code>SIGPIPE</code>, the signal sent to a process when it attempts to write to a pipe without a process connected to the other end. </p>

</div>
</div>
<a class="anchor" id="ac45033fa26fa228758f1ede8c6b60075"></a><!-- doxytag: member="e4c.h::ControlSignalException" ref="ac45033fa26fa228758f1ede8c6b60075" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ac45033fa26fa228758f1ede8c6b60075">ControlSignalException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is the common supertype of all control signal exceptions. </p>
<p>Control signal exceptions are thrown when the process needs to be controlled by the user or some other process. </p>
<p>This is the <em>hierarchy</em> of control signal exceptions: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#ac45033fa26fa228758f1ede8c6b60075" title="This exception is the common supertype of all control signal exceptions.">ControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ae242b32036329b4b0f16b6794649a1ea" title="This exception is thrown to stop the process for later resumption.">StopException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0e007f369ee872435c3b0d78b1516fde" title="This exception is thrown to terminate the process immediately.">KillException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a47ce40cb05abc6376957d7360aab59f0" title="This exception is thrown when the process&#39; terminal is closed.">HangUpException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4" title="This exception is thrown to request the termination of the process.">TerminationException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a" title="This exception is thrown to abort the process.">AbortException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a5ed1159dd09385426e59765b04a90734" title="This exception is thrown when the process has used up the CPU for too long.">CPUTimeException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88" title="This exception is the common supertype of all control signal exceptions caused by the user...">UserControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3" title="This exception is thrown when the user requests to quit the process.">UserQuitException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683" title="This exception is thrown when the user requests to interrupt the process.">UserInterruptionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e" title="This exception is thrown when a user wishes to break the process.">UserBreakException</a></code> </li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5ed1159dd09385426e59765b04a90734"></a><!-- doxytag: member="e4c.h::CPUTimeException" ref="a5ed1159dd09385426e59765b04a90734" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a5ed1159dd09385426e59765b04a90734">CPUTimeException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process has used up the CPU for too long. </p>
<p>CPUTimeException represents <code>SIGXCPU</code>, the signal sent to a process when it has used up the CPU for a duration that exceeds a certain predetermined user-settable value. </p>

</div>
</div>
<a class="anchor" id="a777634d452ce83a6b7cd697c00f7f98b"></a><!-- doxytag: member="e4c.h::e4c_default_signal_mappings" ref="a777634d452ce83a6b7cd697c00f7f98b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__signal__mapping.html">e4c_signal_mapping</a>* <a class="el" href="e4c_8h.html#a777634d452ce83a6b7cd697c00f7f98b">e4c_default_signal_mappings</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The array of predefined signal mappings. </p>

</div>
</div>
<a class="anchor" id="abafe7605b8224c9e5a25942b1b0ab9aa"></a><!-- doxytag: member="e4c.h::ErrorSignalException" ref="abafe7605b8224c9e5a25942b1b0ab9aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#abafe7605b8224c9e5a25942b1b0ab9aa">ErrorSignalException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is the common supertype of all error signal exceptions. </p>
<p>Error signal exceptions are thrown when some error prevents the program to keep executing its normal flow, for example: </p>
<p>This is the <em>hierarchy</em> of error signal exceptions: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#abafe7605b8224c9e5a25942b1b0ab9aa" title="This exception is the common supertype of all error signal exceptions.">ErrorSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a260dfb8d4895201858c3a21669e7f7fe" title="This exception is thrown when the process attempts to execute an illegal instruction.">IllegalInstructionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a" title="This exception is thrown when the process performs an erroneous arithmetic operation.">ArithmeticException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0ee8ec58c2f81654cba3f12d39c2e56d" title="This exception is thrown when the process attempts to write to a broken pipe.">BrokenPipeException</a></code> </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a317656b402c05741fff856f543b1b37b"></a><!-- doxytag: member="e4c.h::FileOpenException" ref="a317656b402c05741fff856f543b1b37b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a317656b402c05741fff856f543b1b37b">FileOpenException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when a file cannot be opened. </p>
<p>FileOpenException is thrown by <code><a class="el" href="e4c_8h.html#aadb996e59894bfeec035af1b8ca0547f" title="Introduces a block of code with automatic acquisition and disposal of a file stream.">e4c_using_file</a></code> when <code>fopen</code> returns <code>NULL</code> for whatever reason. </p>
<p>The specific cause of the error can be determined by checking the <code>error_number</code> of the exception; it captures the value of <code>errno</code> at the time the exception was thrown (right after <code>fopen</code>).  </p>

</div>
</div>
<a class="anchor" id="a47ce40cb05abc6376957d7360aab59f0"></a><!-- doxytag: member="e4c.h::HangUpException" ref="a47ce40cb05abc6376957d7360aab59f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a47ce40cb05abc6376957d7360aab59f0">HangUpException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process' terminal is closed. </p>
<p>HangUpException represents <code>SIGHUP</code>, the signal sent to a process when its controlling terminal is closed. </p>

</div>
</div>
<a class="anchor" id="a260dfb8d4895201858c3a21669e7f7fe"></a><!-- doxytag: member="e4c.h::IllegalInstructionException" ref="a260dfb8d4895201858c3a21669e7f7fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a260dfb8d4895201858c3a21669e7f7fe">IllegalInstructionException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the process attempts to execute an illegal instruction. </p>
<p>IllegalInstructionException represents <code>SIGILL</code>, the signal sent to a process when it attempts to execute a malformed, unknown, or privileged instruction. </p>

</div>
</div>
<a class="anchor" id="a0e007f369ee872435c3b0d78b1516fde"></a><!-- doxytag: member="e4c.h::KillException" ref="a0e007f369ee872435c3b0d78b1516fde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a0e007f369ee872435c3b0d78b1516fde">KillException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown to terminate the process immediately. </p>
<p>KillException represents <code>SIGKILL</code>, the signal sent to a process to cause it to terminate immediately.</p>
<p>Since <code>SIGKILL</code> is unblock-able, it cannot be handled and converted to this exception automatically. </p>

</div>
</div>
<a class="anchor" id="ab79c3dc39a4ab647e41f0f76f3d1193a"></a><!-- doxytag: member="e4c.h::NotEnoughMemoryException" ref="ab79c3dc39a4ab647e41f0f76f3d1193a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ab79c3dc39a4ab647e41f0f76f3d1193a">NotEnoughMemoryException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the system runs out of memory. </p>
<p>NotEnoughMemoryException is thrown when there is not enough memory to continue the execution of the program.  </p>

</div>
</div>
<a class="anchor" id="aab3e04a700f83bd01ca51ccc94ba423e"></a><!-- doxytag: member="e4c.h::NullPointerException" ref="aab3e04a700f83bd01ca51ccc94ba423e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#aab3e04a700f83bd01ca51ccc94ba423e">NullPointerException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when an unexpected null pointer is found. </p>
<p>NullPointerException is thrown when some part of the program gets a pointer which was expected or required to contain a valid memory address.  </p>

</div>
</div>
<a class="anchor" id="ada0f3c6dc452cbf6f7d8b134f0d46a2a"></a><!-- doxytag: member="e4c.h::ProgramSignal1Exception" ref="ada0f3c6dc452cbf6f7d8b134f0d46a2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ada0f3c6dc452cbf6f7d8b134f0d46a2a">ProgramSignal1Exception</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when user-defined conditions occur. </p>
<p>ProgramSignal1Exception represents <code>SIGUSR1</code>, the signal sent to a process to indicate user-defined conditions. </p>

</div>
</div>
<a class="anchor" id="a199dabf2a99ead7e9b904bf739a84196"></a><!-- doxytag: member="e4c.h::ProgramSignal2Exception" ref="a199dabf2a99ead7e9b904bf739a84196" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a199dabf2a99ead7e9b904bf739a84196">ProgramSignal2Exception</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when user-defined conditions occur. </p>
<p>ProgramSignal2Exception represents <code>SIGUSR1</code>, the signal sent to a process to indicate user-defined conditions. </p>

</div>
</div>
<a class="anchor" id="a0e66c61e5b993b919795f5882d0f2623"></a><!-- doxytag: member="e4c.h::ProgramSignalException" ref="a0e66c61e5b993b919795f5882d0f2623" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a0e66c61e5b993b919795f5882d0f2623">ProgramSignalException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is the common supertype of all user-defined signal exceptions. </p>
<p>User-defined signal exceptions are thrown to indicate user-defined conditions. </p>
<p>This is the <em>hierarchy</em> of user-defined signal exceptions: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#a0e66c61e5b993b919795f5882d0f2623" title="This exception is the common supertype of all user-defined signal exceptions.">ProgramSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ada0f3c6dc452cbf6f7d8b134f0d46a2a" title="This exception is thrown when user-defined conditions occur.">ProgramSignal1Exception</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a199dabf2a99ead7e9b904bf739a84196" title="This exception is thrown when user-defined conditions occur.">ProgramSignal2Exception</a></code> </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a25ac8ed644959c0a02ba27134f1d9d96"></a><!-- doxytag: member="e4c.h::RuntimeException" ref="a25ac8ed644959c0a02ba27134f1d9d96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96">RuntimeException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the root of the exception pseudo-hierarchy. </p>
<p>RuntimeException is the common <em>supertype</em> of all exceptions. </p>
<p>This is the <em>hierarchy</em> of runtime exceptions: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#a25ac8ed644959c0a02ba27134f1d9d96" title="This is the root of the exception pseudo-hierarchy.">RuntimeException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ab79c3dc39a4ab647e41f0f76f3d1193a" title="This exception is thrown when the system runs out of memory.">NotEnoughMemoryException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#aab3e04a700f83bd01ca51ccc94ba423e" title="This exception is thrown when an unexpected null pointer is found.">NullPointerException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ad3235203c55e60e7b54884d55d06b6be" title="This exception is the common supertype of all signal exceptions.">SignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a56bb6ac49648349341b8356449fa89c3" title="This exception is thrown when a time limit has elapsed.">SignalAlarmException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a77deb38475061aa2dc40f705b7c40757" title="This exception is thrown when a child process terminates.">SignalChildException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a4c6b68584333142345acb7739a11e062" title="This exception is thrown when a condition arises that a debugger has requested to be informed of...">SignalTrapException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#abafe7605b8224c9e5a25942b1b0ab9aa" title="This exception is the common supertype of all error signal exceptions.">ErrorSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a260dfb8d4895201858c3a21669e7f7fe" title="This exception is thrown when the process attempts to execute an illegal instruction.">IllegalInstructionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a" title="This exception is thrown when the process performs an erroneous arithmetic operation.">ArithmeticException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0ee8ec58c2f81654cba3f12d39c2e56d" title="This exception is thrown when the process attempts to write to a broken pipe.">BrokenPipeException</a></code> </li>
</ul>
</li>
<li>
<code><a class="el" href="e4c_8h.html#ac45033fa26fa228758f1ede8c6b60075" title="This exception is the common supertype of all control signal exceptions.">ControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ae242b32036329b4b0f16b6794649a1ea" title="This exception is thrown to stop the process for later resumption.">StopException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0e007f369ee872435c3b0d78b1516fde" title="This exception is thrown to terminate the process immediately.">KillException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a47ce40cb05abc6376957d7360aab59f0" title="This exception is thrown when the process&#39; terminal is closed.">HangUpException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4" title="This exception is thrown to request the termination of the process.">TerminationException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a" title="This exception is thrown to abort the process.">AbortException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a5ed1159dd09385426e59765b04a90734" title="This exception is thrown when the process has used up the CPU for too long.">CPUTimeException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88" title="This exception is the common supertype of all control signal exceptions caused by the user...">UserControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3" title="This exception is thrown when the user requests to quit the process.">UserQuitException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683" title="This exception is thrown when the user requests to interrupt the process.">UserInterruptionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e" title="This exception is thrown when a user wishes to break the process.">UserBreakException</a></code> </li>
</ul>
</li>
</ul>
</li>
<li>
<code><a class="el" href="e4c_8h.html#a0e66c61e5b993b919795f5882d0f2623" title="This exception is the common supertype of all user-defined signal exceptions.">ProgramSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ada0f3c6dc452cbf6f7d8b134f0d46a2a" title="This exception is thrown when user-defined conditions occur.">ProgramSignal1Exception</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a199dabf2a99ead7e9b904bf739a84196" title="This exception is thrown when user-defined conditions occur.">ProgramSignal2Exception</a></code> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a56bb6ac49648349341b8356449fa89c3"></a><!-- doxytag: member="e4c.h::SignalAlarmException" ref="a56bb6ac49648349341b8356449fa89c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a56bb6ac49648349341b8356449fa89c3">SignalAlarmException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when a time limit has elapsed. </p>
<p>SignalAlarmException represents <code>SIGALRM</code>, the signal sent to a process when a time limit has elapsed. </p>

</div>
</div>
<a class="anchor" id="a77deb38475061aa2dc40f705b7c40757"></a><!-- doxytag: member="e4c.h::SignalChildException" ref="a77deb38475061aa2dc40f705b7c40757" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a77deb38475061aa2dc40f705b7c40757">SignalChildException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when a child process terminates. </p>
<p>SignalChildException represents <code>SIGCHLD</code>, the signal sent to a process when a child process terminates (ignored by default). </p>

</div>
</div>
<a class="anchor" id="ad3235203c55e60e7b54884d55d06b6be"></a><!-- doxytag: member="e4c.h::SignalException" ref="ad3235203c55e60e7b54884d55d06b6be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ad3235203c55e60e7b54884d55d06b6be">SignalException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is the common supertype of all signal exceptions. </p>
<p>Signal exceptions are thrown when some signal is sent to the process. </p>
<p>A signal can be generated by calling <code>raise</code>. </p>
<p>This is the <em>hierarchy</em> of signal exceptions: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#ad3235203c55e60e7b54884d55d06b6be" title="This exception is the common supertype of all signal exceptions.">SignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a56bb6ac49648349341b8356449fa89c3" title="This exception is thrown when a time limit has elapsed.">SignalAlarmException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a77deb38475061aa2dc40f705b7c40757" title="This exception is thrown when a child process terminates.">SignalChildException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a4c6b68584333142345acb7739a11e062" title="This exception is thrown when a condition arises that a debugger has requested to be informed of...">SignalTrapException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#abafe7605b8224c9e5a25942b1b0ab9aa" title="This exception is the common supertype of all error signal exceptions.">ErrorSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a260dfb8d4895201858c3a21669e7f7fe" title="This exception is thrown when the process attempts to execute an illegal instruction.">IllegalInstructionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a6a9181ab0bdb1efc34d23bc5d14b02ea" title="This exception is thrown when the process tries to dereference an invalid pointer.">BadPointerException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ad4d56dfb22dbc20780a5c59eed3a8a7a" title="This exception is thrown when the process performs an erroneous arithmetic operation.">ArithmeticException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0ee8ec58c2f81654cba3f12d39c2e56d" title="This exception is thrown when the process attempts to write to a broken pipe.">BrokenPipeException</a></code> </li>
</ul>
</li>
<li>
<code><a class="el" href="e4c_8h.html#ac45033fa26fa228758f1ede8c6b60075" title="This exception is the common supertype of all control signal exceptions.">ControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ae242b32036329b4b0f16b6794649a1ea" title="This exception is thrown to stop the process for later resumption.">StopException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a0e007f369ee872435c3b0d78b1516fde" title="This exception is thrown to terminate the process immediately.">KillException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a47ce40cb05abc6376957d7360aab59f0" title="This exception is thrown when the process&#39; terminal is closed.">HangUpException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4" title="This exception is thrown to request the termination of the process.">TerminationException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a37904193f6aa65881e748ea0e25d1b5a" title="This exception is thrown to abort the process.">AbortException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a5ed1159dd09385426e59765b04a90734" title="This exception is thrown when the process has used up the CPU for too long.">CPUTimeException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88" title="This exception is the common supertype of all control signal exceptions caused by the user...">UserControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3" title="This exception is thrown when the user requests to quit the process.">UserQuitException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683" title="This exception is thrown when the user requests to interrupt the process.">UserInterruptionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e" title="This exception is thrown when a user wishes to break the process.">UserBreakException</a></code> </li>
</ul>
</li>
</ul>
</li>
<li>
<code><a class="el" href="e4c_8h.html#a0e66c61e5b993b919795f5882d0f2623" title="This exception is the common supertype of all user-defined signal exceptions.">ProgramSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#ada0f3c6dc452cbf6f7d8b134f0d46a2a" title="This exception is thrown when user-defined conditions occur.">ProgramSignal1Exception</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a199dabf2a99ead7e9b904bf739a84196" title="This exception is thrown when user-defined conditions occur.">ProgramSignal2Exception</a></code> </li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a4c6b68584333142345acb7739a11e062"></a><!-- doxytag: member="e4c.h::SignalTrapException" ref="a4c6b68584333142345acb7739a11e062" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a4c6b68584333142345acb7739a11e062">SignalTrapException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when a condition arises that a debugger has requested to be informed of. </p>
<p>SignalTrapException represents <code>SIGTRAP</code>, the signal sent to a process when a condition arises that a debugger has requested to be informed of. </p>

</div>
</div>
<a class="anchor" id="ae242b32036329b4b0f16b6794649a1ea"></a><!-- doxytag: member="e4c.h::StopException" ref="ae242b32036329b4b0f16b6794649a1ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ae242b32036329b4b0f16b6794649a1ea">StopException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown to stop the process for later resumption. </p>
<p>StopException represents <code>SIGSTOP</code>, the signal sent to a process to stop it for later resumption.</p>
<p>Since <code>SIGSTOP</code> is unblock-able, it cannot be handled and converted to this exception automatically. </p>

</div>
</div>
<a class="anchor" id="a36ea459589195777a0189a5edf0983f4"></a><!-- doxytag: member="e4c.h::TerminationException" ref="a36ea459589195777a0189a5edf0983f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a36ea459589195777a0189a5edf0983f4">TerminationException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown to request the termination of the process. </p>
<p>TerminationException represents <code>SIGTERM</code>, the signal sent to a process to request its termination. </p>

</div>
</div>
<a class="anchor" id="a229491b9c8a862e76a7fe13fa909900e"></a><!-- doxytag: member="e4c.h::UserBreakException" ref="a229491b9c8a862e76a7fe13fa909900e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e">UserBreakException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when a user wishes to break the process. </p>
<p>UserBreakException represents <code>SIGBREAK</code>, the signal sent to a process by its controlling terminal when a user wishes to break it. </p>

</div>
</div>
<a class="anchor" id="ac26e60f7bb642461cb3f23b8ce145d88"></a><!-- doxytag: member="e4c.h::UserControlSignalException" ref="ac26e60f7bb642461cb3f23b8ce145d88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88">UserControlSignalException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is the common supertype of all control signal exceptions caused by the user. </p>
<p>User control signal exceptions are thrown when the process needs to be controlled by the user. </p>
<p>This is the <em>hierarchy</em> of control signal exceptions caused by the user: </p>
<ul>
<li>
<code><a class="el" href="e4c_8h.html#ac26e60f7bb642461cb3f23b8ce145d88" title="This exception is the common supertype of all control signal exceptions caused by the user...">UserControlSignalException</a></code><ul>
<li>
<code><a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3" title="This exception is thrown when the user requests to quit the process.">UserQuitException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683" title="This exception is thrown when the user requests to interrupt the process.">UserInterruptionException</a></code> </li>
<li>
<code><a class="el" href="e4c_8h.html#a229491b9c8a862e76a7fe13fa909900e" title="This exception is thrown when a user wishes to break the process.">UserBreakException</a></code> </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a31d8bf96d228e4a541608223a4d95683"></a><!-- doxytag: member="e4c.h::UserInterruptionException" ref="a31d8bf96d228e4a541608223a4d95683" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a31d8bf96d228e4a541608223a4d95683">UserInterruptionException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the user requests to interrupt the process. </p>
<p>UserInterruptionException represents <code>SIGINT</code>, the signal sent to a process by its controlling terminal when a user wishes to interrupt it. </p>

</div>
</div>
<a class="anchor" id="a92585d836747d936952588b32e2cefc3"></a><!-- doxytag: member="e4c.h::UserQuitException" ref="a92585d836747d936952588b32e2cefc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structe4c__exception.html">e4c_exception</a> <a class="el" href="e4c_8h.html#a92585d836747d936952588b32e2cefc3">UserQuitException</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This exception is thrown when the user requests to quit the process. </p>
<p>UserQuitException represents <code>SIGQUIT</code>, the signal sent to a process by its controlling terminal when the user requests that the process dump core. </p>

</div>
</div>
</div>
<hr size="1">
<address style="text-align: center;">
<small>
<div style="float: left; text-align: left;">
<a href="http://code.google.com/p/exceptions4c/">exceptions4c version 2.3</a>
<br/>
Copyright 2010 Guillermo Calvo.
</div>
<div style="float: right; text-align: right;">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB+ElEQVQ4jaVTO4sTURT+5sFOnuxMYsyYTMAwMTAkgUk200waK0EYsLCb1sbeYksHW8FfYKGFUUFYsNFGCIpYBGOTNWJhbCwiCYMQyMZ17rFYbswm4AM/OHDveXz3nI9zBSLC/0Dmh06no85ms+uJROLzYDB49NcMRIRms3lZVdVDURR/ZLPZN9Vq9WqtVtshIvzJBMdxWsPh8OlisShwUkmSjvP5/H1VVd/GYrFP8/l8T5Kk/HK5/A4gisfjYwDy7u7uQ+i6/gwA+515nkdBENCGnxzH2YdlWXa9Xr+kKMo3AMz3fSIi8n2feHGv1yM6UftUXNO0F6tZMpnMawCMJxIR8eITqU77iYgMw/i6Isjlcgc8gSMIgvUrdbtdTkQAKJ1Of1wRmKZ5m7/ked7mvFudbXXQarUuiqJ4zGfkBZsEmxoIfBMtyxIB3JhMJtfCMKwCgCiKR4IgHAGIMcZiRETJZPILACGKop1Go3FnRcDhum55NBo9YYwlDcPYl2X5XSqVssMwbE6n006hUHgsSdLL8Xj83LKsva3Nsm27VKlUbpqmeXczVi6Xb7Xb7RoRoVQqHRDRr7/AoSjKhSiKPhCRse63bTvFGFP7/f6h67rnZFl+D2CbAMAZXddfhWF4dt2padr5RCLxAAAEQbhSLBbvAcCWBv+Kn6GeeP3SvcIWAAAAAElFTkSuQmCC" width="16" height="16" alt="" />
<br/>
Generated on Wed Nov 24 2010 by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.7.2
</div>
</small>
</address>
</body>
</html>
